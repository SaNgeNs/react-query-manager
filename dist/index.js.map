{"version":3,"sources":["../src/utils/custom-error.ts","../src/utils/fetcher.ts"],"names":["CustomError","_CustomError","message","status","data","filterEmptyParams","params","optionParams","key","value","encode","fetcher","onSuccess","onError","context","args","isFormData","apiUrl","URL","queryParams"],"mappings":"AAgBO,y8BAAMA,CAAAA,CAAN,MAAMC,EAAAA,QAAoB,KAAM,CACrC,WAAA,CACoBC,CAAAA,CACAC,CAAAA,CACAC,CAAAA,CAClB,CACA,KAAA,CAAMF,CAAO,CAAA,CAJK,IAAA,CAAA,OAAA,CAAAA,CAAAA,CACA,IAAA,CAAA,MAAA,CAAAC,CAAAA,CACA,IAAA,CAAA,IAAA,CAAAC,CAAAA,CAIlB,MAAA,CAAO,cAAA,CAAe,IAAA,CAAMH,CAAAA,CAAY,SAAS,CAAA,CAEjD,IAAA,CAAK,IAAA,CAAO,IAAA,CAAK,WAAA,CAAY,IAAA,CAEzB,OAAQ,KAAA,CAAc,iBAAA,EAAsB,UAAA,CAC7C,KAAA,CAAc,iBAAA,CAAkB,IAAA,CAAM,IAAA,CAAK,WAAW,CAAA,CAEvD,IAAA,CAAK,KAAA,CAAQ,IAAI,KAAA,CAAMC,CAAO,CAAA,CAAE,KAAA,CAGlC,IAAA,CAAK,KAAA,CAAQ,IAAI,KAAA,CAAM,CAAA,CAAE,KAAA,CAEzB,OAAA,CAAQ,KAAA,CAAM,IAAA,CAAK,OAAA,CAAS,IAAI,CAClC,CACF,CAAA,CC3BO,IAAMG,EAAAA,CAAqBC,CAAAA,EAAgB,CAChD,EAAA,CAAIA,CAAAA,GAAW,IAAA,EAAQ,OAAOA,CAAAA,EAAW,QAAA,CAAU,CACjD,IAAMC,CAAAA,CAAwC,CAAC,CAAA,CAG/C,OAFgB,MAAA,CAAO,OAAA,CAAQD,CAAM,CAAA,CAE7B,OAAA,CAAQ,CAAC,CAACE,CAAAA,CAAKC,CAAK,CAAA,CAAA,EAAM,CAAA,CAC5BA,CAAAA,EAAS,OAAOA,CAAAA,EAAU,SAAA,EAAa,OAAOA,CAAAA,EAAU,QAAA,CAAA,EAAA,CAC1DF,CAAAA,CAAaC,CAAG,CAAA,CAAIC,CAAAA,CAExB,CAAC,CAAA,CAEMF,CACT,CAEA,MAAO,CAAC,CACV,CAAA,CAUaG,CAAAA,CAAUD,CAAAA,EACd,kBAAA,CAAmBA,CAAK,CAAA,CAC5B,OAAA,CAAQ,OAAA,CAAS,GAAG,CAAA,CACpB,OAAA,CAAQ,MAAA,CAAQ,GAAG,CAAA,CACnB,OAAA,CAAQ,OAAA,CAAS,GAAG,CAAA,CACpB,OAAA,CAAQ,MAAA,CAAQ,GAAG,CAAA,CACnB,OAAA,CAAQ,OAAA,CAAS,GAAG,CAAA,CACpB,OAAA,CAAQ,OAAA,CAAS,GAAG,CAAA,CA6BZE,CAAAA,mBAAqB,CAAC,CACjC,SAAA,CAAAC,CAAAA,CAAW,OAAA,CAAAC,CAAAA,CAAS,OAAA,CAAAC,CAAAA,CAAS,GAAGC,CAClC,CAAA,CAAA,EAAM,CACJ,IAAMC,CAAAA,CAAaD,CAAAA,CAAK,KAAA,WAAgB,QAAA,CAElCE,CAAAA,CAAAA,CAAU,CAAA,CAAA,EAAM,CACpB,IAAIC,CAAAA,CAAMH,CAAAA,CAAK,GAAA,CAEf,EAAA,CAAIA,CAAAA,CAAK,MAAA,CAAQ,CACf,IAAMI,CAAAA,CAAcd,EAAAA,CAAkBU,CAAAA,CAAK,MAAM,CAAA,CAEjD,EAAA,CAAIA,CAAAA,CAAK,qBAAA,CACPG,CAAAA,EAAO,CAAA,CAAA,EAAIH,CAAAA,CAAK,qBAAA,CAAsBA,CAAAA,CAAK,MAAM,CAAC,CAAA,CAAA","file":"/home/lven/RQ-lib/react-query-manager/dist/index.js","sourcesContent":["/**\n * Custom error class for handling HTTP request errors.\n *\n * @class\n * @extends {Error}\n * @param message - The error message.\n * @param status - The HTTP status code associated with the error.\n * @param data - Additional data related to the error.\n *\n * @example\n * try {\n *   // Some code that may throw an error\n * } catch (error) {\n *   throw new CustomError('Failed to fetch resource', 500, error);\n * }\n */\nexport class CustomError extends Error {\n  constructor(\n      public readonly message: string,\n      public readonly status?: number,\n      public readonly data?: any,\n  ) {\n    super(message);\n\n    Object.setPrototypeOf(this, CustomError.prototype);\n\n    this.name = this.constructor.name;\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n\n    this.stack = new Error().stack;\n\n    console.error(this.message, this);\n  }\n}\n","import { ApiClient } from '../type';\nimport { CustomError } from './custom-error';\n\n/**\n * Filters out null, undefined, and empty string values from the provided parameters object,\n * while keeping boolean and numeric values intact. The function returns a new object containing\n * only the non-empty parameters.\n *\n * @param {Record<string, any>} params - The object containing the parameters to be filtered.\n * @returns {Record<string, unknown>} A new object with only the non-empty parameters.\n */\nexport const filterEmptyParams = (params: any) => {\n  if (params !== null && typeof params === 'object') {\n    const optionParams: Record<string, unknown> = {};\n    const entries = Object.entries(params);\n\n    entries.forEach(([key, value]) => {\n      if (value || typeof value === 'boolean' || typeof value === 'number') {\n        optionParams[key] = value;\n      }\n    });\n\n    return optionParams;\n  }\n\n  return {};\n};\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param value The value to be encoded.\n *\n * @returns The encoded value.\n */\nexport const encode = (value: string) => {\n  return encodeURIComponent(value)\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5B/gi, '[')\n    .replace(/%5D/gi, ']');\n};\n\n/**\n * A utility function for making API requests.\n *\n * @example\n * import { fetcher } from 'react-query-manager';\n *\n * fetcher({\n *   url: 'https://jsonplaceholder.typicode.com/todos/1',\n *   method: 'GET',\n *   onSuccess: (data, args, context) => {\n *     console.log(data);\n *     console.log(args);\n *     console.log(context);\n *   },\n *   onError: (error, args, context) => {\n *     console.error(error);\n *     console.error(args);\n *     console.error(context);\n *   },\n *   context: { value: '1' }\n * });\n *\n * @param args The request configuration.\n *\n * @returns The response as a promise.\n */\nexport const fetcher: ApiClient = ({\n  onSuccess, onError, context, ...args\n}) => {\n  const isFormData = args.data instanceof FormData;\n\n  const apiUrl = (() => {\n    let URL = args.url;\n\n    if (args.params) {\n      const queryParams = filterEmptyParams(args.params);\n\n      if (args.queryParamsSerializer) {\n        URL += `?${args.queryParamsSerializer(args.params)}`;\n      } else if (Object.keys(queryParams).length > 0) {\n        const str = [];\n\n        for (const p in queryParams) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (queryParams.hasOwnProperty(p)) {\n            if (Array.isArray(queryParams[p])) {\n              queryParams[p].forEach((value) => {\n                str.push(`${encode(p)}${args.queryArrayParamStyle === 'indexedArray' ? '[]' : ''}=${encode(value)}`);\n              });\n            } else {\n              str.push(\n                `${encode(p)}=${encode((queryParams as any)[p])}`,\n              );\n            }\n          }\n        }\n\n        URL += `?${str.join('&')}`;\n      }\n    }\n\n    const [startUrl, endUrl] = URL.split('?');\n\n    return `${startUrl}${endUrl ? `?${endUrl}` : ''}`;\n  })();\n\n  const body = (() => {\n    if (isFormData) {\n      return args.data;\n    }\n\n    if (args.data) {\n      return JSON.stringify(args.data);\n    }\n\n    return '';\n  })();\n\n  const fetchOptions = {\n    method: args.method,\n    headers: {\n      ...(!isFormData && { 'Content-Type': 'application/json' }),\n      ...(args.authorization && { Authorization: args.authorization }),\n      ...args.headers,\n    },\n    ...(body && { body }),\n    ...args.options,\n  };\n\n  return fetch(apiUrl, fetchOptions).then(async (response) => {\n    const responseData = await (async () => {\n      try {\n        const contentLength = response.headers.get('Content-Length');\n        const contentType = response.headers.get('Content-Type')?.toLowerCase();\n\n        if (\n          response.status === 204 ||\n          response.status === 304 ||\n          contentLength === '0' ||\n          !contentType\n        ) {\n          return null;\n        }\n\n        if (contentType.includes('application/json')) {\n          return await response.json();\n        }\n\n        if (\n          contentType.includes('text/plain')\n          || contentType.includes('text/csv')\n          || contentType.includes('application/xml')\n          || contentType.includes('text/xml')\n          || contentType.includes('application/javascript')\n          || contentType.includes('text/html')\n        ) {\n          return await response.text();\n        }\n\n        if (contentType.includes('multipart/form-data')) {\n          return await response.formData();\n        }\n\n        return await response.blob();\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (error) {\n        return null;\n      }\n    })();\n\n    const headers: Record<string, string> = {};\n\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n\n    return {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n      data: responseData,\n    };\n  }).then((result) => {\n    if (result.status < 200 || result.status >= 300) {\n      const error = new CustomError(\n        `Request failed with status code: ${result.status}`,\n        result.status,\n        result.data,\n      );\n\n      if (onError) {\n        onError(error, args, context);\n      }\n\n      return Promise.reject(error);\n    }\n\n    if (onSuccess) {\n      onSuccess(result, args, context);\n    }\n\n    return Promise.resolve(result);\n  }).catch((error) => {\n    return Promise.reject(new CustomError(\n      error.message,\n    ));\n  });\n};\n"]}