{"version":3,"sources":["../src/index.ts","../src/internal/utils/internal.ts","../src/utils/get-url-from-resource.ts","../src/components/RQWrapper.tsx","../src/utils/custom-error.ts","../src/utils/fetcher.ts"],"names":["mergeObjects","target","source","result","key","targetValue","sourceValue","createSnapshot","queryClient","keys","snapshot","prev","queryKey","removeFirstAndLastSlash","path","eventEmitter","EventEmitter","undoEventEmitter","type","callback","isUndo","getUrlFromResource","resource","url","_","CustomError","_CustomError","message","status","data","encode","value","fetcher","args","onSuccess","onError","isFormData","apiUrl","URL"],"mappings":"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","file":"/home/lven/RQ-lib/react-query-manager/dist/index.js","sourcesContent":["export * from '@tanstack/react-query';\n\nexport * from './hooks/use-get-list';\nexport * from './hooks/use-get-infinite-list';\nexport * from './hooks/use-get-one';\nexport * from './hooks/use-delete';\nexport * from './hooks/use-update';\nexport * from './hooks/use-create';\n\nexport * from './components/RQWrapper';\n\nexport * from './utils/fetcher';\nexport * from './utils/custom-error';\nexport * from './utils/toast';\nexport * from './utils/get-url-from-resource';\nexport * from './utils/queries';\n\nexport * from './type';\n","/* eslint-disable no-restricted-syntax */\nimport type { QueryClient } from '@tanstack/react-query';\nimport EventEmitter from 'eventemitter3';\nimport { Snapshot } from '../type';\n\n/**\n * Recursively merges two objects together, ensuring that only fields that exist\n * and match in type in the target object are merged from the source object.\n *\n * @template TData - The type of the target object.\n * @param target - The target object that will be merged into.\n * @param source - The source object containing values to merge.\n * Only properties that exist in the target object and have matching types will be merged.\n *\n * @returns A new object with the merged values from the target and source objects.\n *\n * @example\n * const target = { id: '1', name: 'Test' };\n * const source = { id: '1', name: 'Test 2', other: 'Ignored' };\n * const result = mergeObjects(target, source);\n * ---> result: { id: '1', name: 'Test 2' }\n */\nexport function mergeObjects<TData extends object>(target: TData, source: any): TData {\n  const result: any = { ...target };\n\n  if (target instanceof Object && source instanceof Object) {\n    for (const key in source) {\n      if (key in target) {\n        const targetValue = (target as any)[key];\n        const sourceValue = source[key];\n\n        const isSameType = typeof targetValue === typeof sourceValue\n          && ((Array.isArray(targetValue) && Array.isArray(sourceValue))\n          || (targetValue !== null && !Array.isArray(targetValue) && typeof targetValue === 'object'\n            && !Array.isArray(sourceValue) && typeof sourceValue === 'object')\n          || (typeof targetValue !== 'object' && typeof sourceValue !== 'object'));\n\n        if (isSameType) {\n          if (typeof targetValue === 'object' && targetValue !== null && !Array.isArray(targetValue)) {\n            result[key] = mergeObjects(targetValue, sourceValue as typeof targetValue);\n          } else {\n            result[key] = sourceValue;\n          }\n        }\n      }\n    }\n  }\n\n  return result as TData;\n}\n\n/**\n * Creates a snapshot of the current data in the cache.\n *\n * @param queryClient The query client that contains the data to be snapshotted.\n * @param keys The keys to be snapshotted.\n * @returns A snapshot of the current data in the cache.\n */\nexport const createSnapshot = async (queryClient: QueryClient, keys: any[][]) => {\n  const snapshot: Snapshot = keys.reduce(\n    (prev, queryKey) => prev.concat(queryClient.getQueriesData({ queryKey })),\n    [] as any,\n  );\n\n  // Cancel any outgoing re-fetches (so they don't overwrite our optimistic update)\n  await Promise.all(\n    snapshot.map(([queryKey]) => queryClient.cancelQueries({ queryKey })),\n  );\n\n  return snapshot;\n};\n\n/**\n * Removes leading and trailing slashes from the given string.\n *\n * @param path The string to remove slashes from.\n * @return The string with leading and trailing slashes removed.\n */\nexport function removeFirstAndLastSlash(path: string): string {\n  return path\n    .replace(/^\\/+/, '')\n    .replace(/\\/+$/, '');\n}\n\nconst eventEmitter = new EventEmitter();\n\nexport const undoEventEmitter = {\n  /**\n   * Listens for the next 'end' event and then removes the listener.\n   *\n   * @param type The type of event to listen for. Currently only 'end' is supported.\n   * @param callback The callback function to be called when the event is emitted. The callback will receive a boolean indicating whether the event was triggered by an undo action.\n   * @return A function that can be called to remove the listener.\n   */\n  once: (type: 'end', callback: (isUndo: boolean) => void) => {\n    eventEmitter.once(type, callback);\n  },\n  /**\n   * Emits an 'end' event, which is used to let any registered callbacks know that an undo/redo action has completed.\n   *\n   * @param type The type of event to emit. Currently only 'end' is supported.\n   * @param isUndo A boolean indicating whether the event was triggered by an undo action.\n   */\n  emit: (type: 'end', isUndo: boolean) => {\n    eventEmitter.emit(type, isUndo);\n  },\n};\n","import { Resource } from '../type';\nimport { removeFirstAndLastSlash } from '../internal/utils/internal';\n\n/**\n * Takes a `Resource` object and returns its path as a string,\n * with any path parameters replaced with their corresponding values.\n *\n * @example\n * const resource = {\n *   path: 'users/{id}/messages',\n *   params: { id: 1 },\n * };\n *\n * getUrlFromResource(resource); // 'users/1/messages'\n */\nexport const getUrlFromResource = <TPath extends string>(resource: Resource<TPath>) => {\n  const url = resource.path.replace(/{(\\w+)}/g, (_, key: keyof Resource<TPath>['params']) => {\n    return resource.params[key]!.toString();\n  });\n\n  return removeFirstAndLastSlash(url);\n};\n","import { QueryClient, QueryClientConfig, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\nimport React, {\n  createContext, ReactNode, useCallback, useContext, useMemo,\n} from 'react';\nimport { fetcher } from '../utils/fetcher';\nimport {\n  ApiProps, ApiClient, ToastProps, ToastCustomWrapper,\n  CustomUndoContent,\n  RQWrapperContextProps,\n} from '../type';\nimport { Toaster } from '../internal/components/Toaster';\nimport { toast } from '../utils/toast';\nimport { removeFirstAndLastSlash, undoEventEmitter } from '../internal/utils/internal';\n\nconst Context = createContext<RQWrapperContextProps>({\n  apiUrl: '',\n  apiClient: fetcher,\n  toastUndo: () => {},\n});\n\n/**\n * Get the context for the RQWrapper component.\n *\n * This hook returns the context for the RQWrapper component, which includes the\n * API URL, API client, and toast undo function.\n *\n * @returns The RQWrapper context.\n */\nexport const useRQWrapperContext = () => {\n  return useContext(Context);\n};\n\ntype ReactQueryDevtoolsProps = React.ComponentProps<typeof ReactQueryDevtools>;\n\n/**\n * This component wraps your application and provides the necessary context\n * for the hooks to work.\n *\n * @example\n * import { RQWrapper, ToastCustomWrapper, ToastBar } from 'react-query-manager';\n *\n * const ToastWrapper: ToastCustomWrapper = (props) => {\n *  return <ToastBar toast={props} position={props.position} />;\n * };\n *\n * <RQWrapper\n *  isDevTools\n *   devToolsOptions={{\n *     buttonPosition: 'bottom-left',\n *   }}\n *   apiUrl=\"https://jsonplaceholder.typicode.com\"\n *   apiAuthorization={() => 'Bearer 12345'}\n *   apiOnSuccess={(...args) => {\n *     console.log('apiOnSuccess: ', args);\n *   }}\n *   apiOnError={(...args) => {\n *     console.log('apiOnError: ', args);\n *   }}\n *   toast={{\n *     globalProps: {\n *       position: 'bottom-center',\n *     },\n *     wrapper: ToastWrapper,\n *   }}\n * >\n *   <List />\n * </RQWrapper>\n *\n * @param props\n * @param props.children - The children components to render.\n * @param props.config - The configuration for the underlying QueryClient instance.\n * @param props.apiUrl - The base URL for all API requests.\n * @param props.apiClient - The function to use for making API requests.\n *   Defaults to `fetcher` from `react-query-manager`.\n * @param props.apiAuthorization - A function to get the authorization\n *   token for API requests. If not provided, or if the function returns an empty\n *   string, no authorization token will be used.\n * @param props.apiHeaders - A function to get the headers\n *   for API requests. If not provided, or if the function returns an empty\n *   object, no headers will be used.\n * @param props.apiOnSuccess - A callback to run when an API\n *   request is successful. If not provided, the default behavior will be used.\n * @param props.apiOnError - A callback to run when an API\n *   request fails. If not provided, the default behavior will be used.\n * @param props.isDevTools - Whether to render the React Query devtools.\n *   Defaults to `false`.\n * @param props.devToolsOptions - Options to pass to the\n *   React Query devtools.\n * @param props.toast - Options for the\n *   `toast` utility from `react-hot-toast`.\n *   See the [documentation](https://react-hot-toast.com/docs) for more details.\n *\n *   The `wrapper` property can be used to customize the toast component.\n *\n *   The `globalProps` property can be used to customize the default props for the toast component.\n *\n *   The `customUndoContent` property can be used to customize the content of the toast when the user\n *   clicks the \"UNDO\" button.\n */\nexport function RQWrapper({\n  children,\n  config = {},\n  apiUrl,\n  apiClient = fetcher,\n  apiAuthorization,\n  apiHeaders,\n  apiOnSuccess,\n  apiOnError,\n  isDevTools,\n  devToolsOptions,\n  toast: toastProps,\n}: {\n  children: ReactNode;\n  config?: QueryClientConfig;\n  apiUrl: string;\n  apiClient?: ApiClient;\n  apiAuthorization?: () => string;\n  apiHeaders?: () => ApiProps['headers'];\n  apiOnSuccess?: ApiProps['onSuccess'];\n  apiOnError?: ApiProps['onError'];\n  isDevTools?: boolean;\n  devToolsOptions?: ReactQueryDevtoolsProps;\n  toast?: {\n    wrapper?: ToastCustomWrapper;\n    globalProps?: ToastProps;\n    customUndoContent?: CustomUndoContent;\n  };\n}) {\n  const queryClient = useMemo(() => {\n    return new QueryClient({\n      ...config,\n      defaultOptions: {\n        ...config?.defaultOptions,\n        queries: {\n          gcTime: 5 * 60 * 1000, // 5 minutes,\n          staleTime: 5 * 60 * 1000, // 5 minutes\n          retry: false,\n          ...config?.defaultOptions?.queries,\n        },\n      },\n    });\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const fetch = useCallback<ApiClient>((args) => {\n    const globalAuthorization = apiAuthorization ? apiAuthorization() : '';\n    const globalHeaders = apiHeaders ? apiHeaders() : {};\n\n    const onSuccess: ApiProps['onSuccess'] = (...successArgs) => {\n      if (apiOnSuccess) {\n        apiOnSuccess(...successArgs);\n      }\n\n      if (args.onSuccess) {\n        args.onSuccess(...successArgs);\n      }\n    };\n\n    const onError: ApiProps['onError'] = (...errorArgs) => {\n      if (apiOnError) {\n        apiOnError(...errorArgs);\n      }\n\n      if (args.onError) {\n        args.onError(...errorArgs);\n      }\n    };\n\n    return apiClient({\n      ...args,\n      headers: args.headers ? {\n        ...globalHeaders,\n        ...args.headers,\n      } : globalHeaders,\n      authorization: args.authorization || globalAuthorization,\n      onSuccess,\n      onError,\n    });\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const toastUndo = useCallback<RQWrapperContextProps['toastUndo']>((data) => {\n    let isSuccess = false;\n\n    toast.dismiss();\n\n    const onUndo = () => {\n      isSuccess = true;\n      undoEventEmitter.emit('end', true);\n      toast.dismiss();\n    };\n\n    const customContent = toastProps?.customUndoContent ? toastProps?.customUndoContent({\n      message: data.message,\n      onUndo,\n      type: data.type,\n    }) : null;\n\n    toast.success(\n      (t) => {\n        if (!t.visible && !isSuccess) {\n          isSuccess = true;\n          undoEventEmitter.emit('end', false);\n        }\n\n        return customContent || (\n          <>\n            {data.message}\n\n            <span\n              style={{ marginLeft: '10px', cursor: 'pointer' }}\n              onClick={onUndo}\n              role=\"button\"\n              tabIndex={0}\n              aria-label=\"Undo\"\n              title=\"Undo\"\n            >\n              UNDO\n            </span>\n          </>\n        );\n      },\n      { duration: toastProps?.globalProps?.toastOptions?.duration || 5000 },\n    );\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const contextValue = useMemo<RQWrapperContextProps>(() => ({\n    apiUrl: removeFirstAndLastSlash(apiUrl),\n    apiClient: fetch,\n    toastUndo,\n  }), [apiUrl, fetch, toastUndo]);\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Toaster {...toastProps?.globalProps}>\n        {toastProps?.wrapper}\n      </Toaster>\n\n      <Context.Provider value={contextValue}>\n        {children}\n      </Context.Provider>\n\n      {isDevTools && (\n        <ReactQueryDevtools\n          buttonPosition=\"bottom-right\"\n          initialIsOpen={false}\n          {...devToolsOptions}\n        />\n      )}\n    </QueryClientProvider>\n  );\n}\n","/**\n * Custom error class for handling HTTP request errors.\n *\n * @class\n * @extends {Error}\n * @param message - The error message.\n * @param status - The HTTP status code associated with the error.\n * @param data - Additional data related to the error.\n *\n * @example\n * try {\n *   // Some code that may throw an error\n * } catch (error) {\n *   throw new CustomError('Failed to fetch resource', 500, error);\n * }\n */\nexport class CustomError extends Error {\n  constructor(\n      public readonly message: string,\n      public readonly status?: number,\n      public readonly data?: any,\n  ) {\n    super(message);\n\n    Object.setPrototypeOf(this, CustomError.prototype);\n\n    this.name = this.constructor.name;\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n\n    this.stack = new Error().stack;\n\n    // eslint-disable-next-line no-console\n    console.error(this.message, this);\n  }\n}\n","/* eslint-disable no-console */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable no-prototype-builtins */\n\nimport { ApiClient } from '../type';\nimport { CustomError } from './custom-error';\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param value The value to be encoded.\n *\n * @returns The encoded value.\n */\nfunction encode(value: string) {\n  return encodeURIComponent(value)\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5B/gi, '[')\n    .replace(/%5D/gi, ']');\n}\n\n/**\n * A utility function for making API requests.\n *\n * @example\n * import { fetcher } from 'react-query-manager';\n *\n * fetcher({\n *   url: 'https://jsonplaceholder.typicode.com/todos/1',\n *   method: 'GET',\n *   onSuccess: (data, args) => {\n *     console.log(data);\n *   },\n *   onError: (error, args) => {\n *     console.error(error);\n *   },\n * });\n *\n * @param args The request configuration.\n *\n * @returns The response as a promise.\n */\nexport const fetcher: ApiClient = (args) => {\n  const { onSuccess, onError } = args;\n\n  const isFormData = args.data instanceof FormData;\n\n  const apiUrl = (() => {\n    let URL = args.url;\n\n    if (args.params) {\n      if (args.queryParamsSerializer) {\n        URL += `?${args.queryParamsSerializer(args.params)}`;\n      } else if (Object.keys(args.params).length > 0) {\n        const str = [];\n\n        for (const p in args.params) {\n          if (args.params.hasOwnProperty(p)) {\n            if (Array.isArray(args.params[p])) {\n              args.params[p].forEach((value) => {\n                str.push(`${encode(p)}${args.queryArrayParamStyle === 'indexedArray' ? '[]' : ''}=${encode(value)}`);\n              });\n            } else {\n              str.push(\n                `${encode(p)}=${encode((args.params as any)[p])}`,\n              );\n            }\n          }\n        }\n\n        URL += `?${str.join('&')}`;\n      }\n    }\n\n    const [startUrl, endUrl] = URL.split('?');\n\n    if (startUrl.charAt(startUrl.length - 1) !== '/' && !endUrl) {\n      return `${startUrl}/${`${endUrl ? `?${endUrl}` : ''}`}`;\n    }\n\n    return `${startUrl}${endUrl ? `?${endUrl}` : ''}`;\n  })();\n\n  const body = (() => {\n    if (isFormData) {\n      return args.data;\n    }\n\n    if (args.data) {\n      return JSON.stringify(args.data);\n    }\n\n    return '';\n  })();\n\n  const fetchOptions = {\n    method: args.method,\n    headers: {\n      ...(!isFormData && { 'Content-Type': 'application/json' }),\n      ...(args.authorization && { Authorization: args.authorization }),\n      ...args.headers,\n    },\n    ...(body && { body }),\n    ...args.options,\n  };\n\n  return fetch(apiUrl, fetchOptions).then(async (response) => {\n    const responseData = await (async () => {\n      try {\n        const contentType = response.headers.get('Content-Type')?.toLowerCase() || '';\n\n        if (contentType.includes('application/json')) {\n          return await response.json();\n        }\n\n        if (\n          contentType.includes('text/plain')\n          || contentType.includes('text/csv')\n          || contentType.includes('application/xml')\n          || contentType.includes('text/xml')\n          || contentType.includes('application/javascript')\n          || contentType.includes('text/html')\n        ) {\n          return await response.text();\n        }\n\n        if (contentType.includes('multipart/form-data')) {\n          return await response.formData();\n        }\n\n        return await response.blob();\n      } catch (error) {\n        console.error('Error handling response:', error);\n        throw error;\n      }\n    })();\n\n    const headers: Record<string, string> = {};\n\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n\n    return {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n      data: responseData,\n    };\n  }).then((result) => {\n    if (result.status < 200 || result.status >= 300) {\n      const error = new CustomError(\n        `Request failed with status code: ${result.status}`,\n        result.status,\n        result.data,\n      );\n\n      if (onError) {\n        onError(error, args);\n      }\n\n      return Promise.reject(error);\n    }\n\n    if (onSuccess) { onSuccess(result, args); }\n\n    return Promise.resolve(result);\n  }).catch((error) => {\n    return Promise.reject(new CustomError(\n      error.message,\n    ));\n  });\n};\n"]}