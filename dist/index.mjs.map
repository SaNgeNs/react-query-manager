{"version":3,"sources":["../src/utils/custom-error.ts","../src/utils/fetcher.ts","../src/index.ts","../src/hooks/use-get-list.ts","../src/internal/utils/remove-first-and-last-slash.ts","../src/utils/get-url-from-resource.ts","../src/components/RQWrapper.tsx","../src/internal/components/Toaster.tsx","../src/utils/toast.ts","../src/internal/utils/undo-event-emitter.ts","../src/internal/env.ts","../src/internal/query-client.ts","../src/hooks/use-get-infinite-list.ts","../src/hooks/use-get-one.ts","../src/hooks/use-delete.ts","../src/utils/queries/add-item-to-query-cache.ts","../src/utils/queries/add-items-to-list-query-cache.ts","../src/utils/queries/remove-queries.ts","../src/utils/queries/delete-items-from-query-cache.ts","../src/utils/queries/helpers-query-keys.ts","../src/internal/utils/is-equal.ts","../src/utils/queries/invalidate-matching-queries.ts","../src/utils/queries/remove-matching-queries.ts","../src/utils/queries/invalidate-queries.ts","../src/internal/utils/merge-objects.ts","../src/utils/queries/update-items-from-query-cache.ts","../src/internal/utils/create-snapshot.ts","../src/hooks/use-update.ts","../src/hooks/use-create.ts","../src/hooks/use-data-query.ts","../src/hooks/use-data-mutate.ts"],"sourcesContent":["/**\n * Custom error class for handling HTTP request errors.\n *\n * @class\n * @extends {Error}\n * @param message - The error message.\n * @param status - The HTTP status code associated with the error.\n * @param data - Additional data related to the error.\n *\n * @example\n * try {\n *   // Some code that may throw an error\n * } catch (error) {\n *   throw new CustomError('Failed to fetch resource', 500, error);\n * }\n */\nexport class CustomError extends Error {\n  constructor(\n      public readonly message: string,\n      public readonly status?: number,\n      public readonly data?: any,\n  ) {\n    super(message);\n\n    Object.setPrototypeOf(this, CustomError.prototype);\n\n    this.name = this.constructor.name;\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n\n    this.stack = new Error().stack;\n\n    console.error(this.message, this);\n  }\n}\n","import { ApiClient } from '../type';\nimport { CustomError } from './custom-error';\n\n/**\n * Filters out null, undefined, and empty string values from the provided parameters object,\n * while keeping boolean and numeric values intact. The function returns a new object containing\n * only the non-empty parameters.\n *\n * @param {Record<string, any>} params - The object containing the parameters to be filtered.\n * @returns {Record<string, unknown>} A new object with only the non-empty parameters.\n */\nexport const filterEmptyParams = (params: any) => {\n  if (params !== null && typeof params === 'object') {\n    const optionParams: Record<string, unknown> = {};\n    const entries = Object.entries(params);\n\n    entries.forEach(([key, value]) => {\n      if (value || typeof value === 'boolean' || typeof value === 'number') {\n        optionParams[key] = value;\n      }\n    });\n\n    return optionParams;\n  }\n\n  return {};\n};\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param value The value to be encoded.\n *\n * @returns The encoded value.\n */\nexport const encode = (value: string) => {\n  return encodeURIComponent(value)\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%20/g, '+')\n    .replace(/%5B/gi, '[')\n    .replace(/%5D/gi, ']');\n};\n\n/**\n * A utility function for making API requests.\n *\n * @example\n * import { fetcher } from 'react-query-manager';\n *\n * fetcher({\n *   url: 'https://jsonplaceholder.typicode.com/todos/1',\n *   method: 'GET',\n *   onSuccess: (data, args, context) => {\n *     console.log(data);\n *     console.log(args);\n *     console.log(context);\n *   },\n *   onError: (error, args, context) => {\n *     console.error(error);\n *     console.error(args);\n *     console.error(context);\n *   },\n *   context: { value: '1' }\n * });\n *\n * @param args The request configuration.\n *\n * @returns The response as a promise.\n */\nexport const fetcher: ApiClient = ({\n  onSuccess, onError, context, ...args\n}) => {\n  const isFormData = args.data instanceof FormData;\n\n  const apiUrl = (() => {\n    let URL = args.url;\n\n    if (args.params) {\n      const queryParams = filterEmptyParams(args.params);\n\n      if (args.queryParamsSerializer) {\n        URL += `?${args.queryParamsSerializer(args.params)}`;\n      } else if (Object.keys(queryParams).length > 0) {\n        const str = [];\n\n        for (const p in queryParams) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (queryParams.hasOwnProperty(p)) {\n            if (Array.isArray(queryParams[p])) {\n              queryParams[p].forEach((value) => {\n                str.push(`${encode(p)}${args.queryArrayParamStyle === 'indexedArray' ? '[]' : ''}=${encode(value)}`);\n              });\n            } else {\n              str.push(\n                `${encode(p)}=${encode((queryParams as any)[p])}`,\n              );\n            }\n          }\n        }\n\n        URL += `?${str.join('&')}`;\n      }\n    }\n\n    const [startUrl, endUrl] = URL.split('?');\n\n    return `${startUrl}${endUrl ? `?${endUrl}` : ''}`;\n  })();\n\n  const body = (() => {\n    if (isFormData) {\n      return args.data;\n    }\n\n    if (args.data) {\n      return JSON.stringify(args.data);\n    }\n\n    return '';\n  })();\n\n  const fetchOptions = {\n    method: args.method,\n    headers: {\n      ...(!isFormData && { 'Content-Type': 'application/json' }),\n      ...(args.authorization && { Authorization: args.authorization }),\n      ...args.headers,\n    },\n    ...(body && { body }),\n    ...args.options,\n  };\n\n  return fetch(apiUrl, fetchOptions).then(async (response) => {\n    const responseData = await (async () => {\n      try {\n        const contentLength = response.headers.get('Content-Length');\n        const contentType = response.headers.get('Content-Type')?.toLowerCase();\n\n        if (\n          response.status === 204 ||\n          response.status === 304 ||\n          contentLength === '0' ||\n          !contentType\n        ) {\n          return null;\n        }\n\n        if (contentType.includes('application/json')) {\n          return await response.json();\n        }\n\n        if (\n          contentType.includes('text/plain')\n          || contentType.includes('text/csv')\n          || contentType.includes('application/xml')\n          || contentType.includes('text/xml')\n          || contentType.includes('application/javascript')\n          || contentType.includes('text/html')\n        ) {\n          return await response.text();\n        }\n\n        if (contentType.includes('multipart/form-data')) {\n          return await response.formData();\n        }\n\n        return await response.blob();\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (error) {\n        return null;\n      }\n    })();\n\n    const headers: Record<string, string> = {};\n\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n\n    return {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n      data: responseData,\n    };\n  }).then((result) => {\n    if (result.status < 200 || result.status >= 300) {\n      const error = new CustomError(\n        `Request failed with status code: ${result.status}`,\n        result.status,\n        result.data,\n      );\n\n      if (onError) {\n        onError(error, args, context);\n      }\n\n      return Promise.reject(error);\n    }\n\n    if (onSuccess) {\n      onSuccess(result, args, context);\n    }\n\n    return Promise.resolve(result);\n  }).catch((error) => {\n    return Promise.reject(new CustomError(\n      error.message,\n    ));\n  });\n};\n","import { fetcher } from './utils/fetcher';\n\nexport * from '@tanstack/react-query';\n\nexport * from './hooks/use-get-list';\nexport * from './hooks/use-get-infinite-list';\nexport * from './hooks/use-get-one';\nexport * from './hooks/use-delete';\nexport * from './hooks/use-update';\nexport * from './hooks/use-create';\nexport * from './hooks/use-data-query';\nexport * from './hooks/use-data-mutate';\n\nexport * from './components/RQWrapper';\n\nexport * from './utils/custom-error';\nexport * from './utils/toast';\nexport * from './utils/get-url-from-resource';\nexport * from './utils/queries';\n\nexport * from './type';\n\nexport { fetcher };\n","import { useQuery } from '@tanstack/react-query';\nimport {\n  Resource,\n  UseQueryProps,\n  QueryResponse,\n  QueryListKey,\n  ApiProps,\n} from '../type';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { CustomError } from '../utils/custom-error';\n\n/**\n * A hook that helps you fetch a list of resources.\n *\n * The hook uses `useQuery` from `@tanstack/react-query` to fetch data and cache it.\n * It accepts various query options and performs an API request to fetch a list of resources\n * based on the provided `resource` and `params`. The hook supports additional query parameters\n * and custom API client parameters.\n *\n * If a custom `queryFn` is provided, it will be used to perform the query; otherwise,\n * the default API client method will be used. The `queryKey` is constructed based on\n * the resource path and additional parameters to ensure proper caching and refetching.\n *\n * @example\n * import { useGetList } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * const PATH = 'users/{id}/messages';\n *\n * const queryList = useGetList<typeof PATH, TData>({\n *   resource: { path: PATH, params: { id: 1 } },\n *   queryOptions: {\n *     onSuccess: (data) => {\n *       console.log('Data fetched successfully:', data);\n *     },\n *   },\n *   params: { sortBy: 'price', order: 'asc' },\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n *\n * @param params The parameters for the hook.\n * @param params.queryOptions - Additional options to configure the `useQuery`\n * @param params.resource - The resource path and any static parameters for the API request.\n * @param params.params - Dynamic query parameters for the API request.\n * @param params.apiClientParams - Additional options to pass to the API client.\n *\n * @returns The result of the `useQuery` hook.\n */\nexport const useGetList = <TPath extends string, TData = any>({\n  queryOptions,\n  resource,\n  params = {},\n  apiClientParams,\n}: {\n  queryOptions?: UseQueryProps<\n    QueryResponse<TData[]>,\n    QueryListKey<TPath>,\n    {\n      resource: Resource<TPath>;\n      params: QueryListKey<TPath>['3'];\n      queryKey: QueryListKey<TPath>;\n    }\n  >;\n  resource: Resource<TPath>;\n  params?: QueryListKey<TPath>['3'];\n  apiClientParams?: Partial<ApiProps>;\n}) => {\n  const { apiUrl, apiClient, apiEnsureTrailingSlash } = useRQWrapperContext();\n\n  const query = useQuery<\n    QueryResponse<TData[]>,\n    CustomError,\n    QueryResponse<TData[]>,\n    QueryListKey<TPath>\n  >({\n    ...queryOptions,\n    queryKey: [\n      'get-list',\n      resource.path,\n      resource.params,\n      params,\n      ...(queryOptions?.queryKey ? queryOptions.queryKey : []),\n    ] as QueryListKey<TPath>,\n    queryFn: async ({ queryKey }) => {\n      const variables = { resource, params, queryKey };\n\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, apiEnsureTrailingSlash)}`;\n\n      if (queryOptions?.queryFn) {\n        const results = await queryOptions?.queryFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const result = await apiClient({\n        url, method: 'GET', params, ...apiClientParams,\n      });\n\n      return result;\n    },\n  });\n\n  return query;\n};\n","/**\n * Removes leading and trailing slashes from the given string.\n *\n * @param path The string to remove slashes from.\n * @return The string with leading and trailing slashes removed.\n */\nexport function removeFirstAndLastSlash(path: string): string {\n  return path\n    .replace(/^\\/+/, '')\n    .replace(/\\/+$/, '');\n}\n","import { removeFirstAndLastSlash } from '../internal/utils/remove-first-and-last-slash';\nimport { Resource } from '../type';\n\n/**\n * Takes a `Resource` object and returns its path as a string,\n * with any path parameters replaced with their corresponding values.\n * Optionally, it can ensure that the returned URL has a trailing slash.\n *\n * @template TPath - A string literal representing the path template with placeholders.\n *\n * @param {Resource<TPath>} resource - The `Resource` object containing the path and parameters.\n * @param {boolean} ensureTrailingSlash - If `true`, the returned URL will have a trailing slash.\n *\n * @returns {string} The URL with all placeholders replaced by the corresponding values from `params`.\n *\n * @example\n * const resource = {\n *   path: 'users/{id}/messages',\n *   params: { id: 1 },\n * };\n *\n * getUrlFromResource(resource, false); // 'users/1/messages'\n * getUrlFromResource(resource, true);  // 'users/1/messages/'\n */\nexport const getUrlFromResource = <TPath extends string>(resource: Resource<TPath>, ensureTrailingSlash?: boolean) => {\n  const url = removeFirstAndLastSlash(resource.path.replace(/{(\\w+)}/g, (_, key: keyof Resource<TPath>['params']) => {\n    return resource.params[key]!.toString();\n  }));\n\n  return ensureTrailingSlash ? `${url}/` : url;\n};\n","import { QueryClient, QueryClientConfig, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\nimport React, {\n  createContext, ReactNode, useCallback, useContext, useMemo,\n} from 'react';\nimport { fetcher } from '../utils/fetcher';\nimport {\n  ApiProps, ApiClient, ToastProps, ToastCustomContent,\n  ToastCustomUndoContent,\n  RQWrapperContextProps,\n} from '../type';\nimport { Toaster } from '../internal/components/Toaster';\nimport { toast } from '../utils/toast';\nimport { undoEventEmitter } from '../internal/utils/undo-event-emitter';\nimport { removeFirstAndLastSlash } from '../internal/utils/remove-first-and-last-slash';\nimport { IS_TEST_ENV } from '../internal/env';\nimport { queryClientManager } from '../internal/query-client';\n\nconst Context = createContext<RQWrapperContextProps>({\n  apiUrl: '',\n  apiEnsureTrailingSlash: false,\n  apiClient: fetcher,\n  toastUndo: () => {},\n});\n\n/**\n * Get the context for the RQWrapper component.\n *\n * This hook returns the context for the RQWrapper component, which includes the\n * API URL, API client, and toast undo function.\n *\n * @returns The RQWrapper context.\n */\nexport const useRQWrapperContext = () => {\n  return useContext(Context);\n};\n\ntype ReactQueryDevtoolsProps = React.ComponentProps<typeof ReactQueryDevtools>;\n\n/**\n * This component wraps your application and provides the necessary context\n * for the hooks to work.\n *\n * @example\n * import { RQWrapper, ToastCustomContent, ToastBar } from 'react-query-manager';\n *\n * const ToastWrapper: ToastCustomContent = (props) => {\n *  return <ToastBar toast={props} position={props.position} />;\n * };\n *\n * <RQWrapper\n *  isDevTools\n *   devToolsOptions={{\n *     buttonPosition: 'bottom-left',\n *   }}\n *   apiUrl=\"https://jsonplaceholder.typicode.com\"\n *   apiAuthorization={() => 'Bearer 12345'}\n *   apiOnSuccess={(...args) => {\n *     console.log('apiOnSuccess: ', args);\n *   }}\n *   apiOnError={(...args) => {\n *     console.log('apiOnError: ', args);\n *   }}\n *   toast={{\n *     globalProps: {\n *       position: 'bottom-center',\n *     },\n *     wrapper: ToastWrapper,\n *   }}\n * >\n *   <List />\n * </RQWrapper>\n *\n * @param props\n * @param props.children - The children components to render.\n * @param props.config - The configuration for the underlying QueryClient instance.\n * @param props.apiUrl - The base URL for all API requests.\n * @param props.apiClient - The function to use for making API requests.\n *   Defaults to `fetcher` from `react-query-manager`.\n * @param props.apiEnsureTrailingSlash - If `true`, the returned URL will have a trailing slash.\n * @param props.apiAuthorization - A function to get the authorization\n *   token for API requests. If not provided, or if the function returns an empty\n *   string, no authorization token will be used.\n * @param props.apiHeaders - A function to get the headers\n *   for API requests. If not provided, or if the function returns an empty\n *   object, no headers will be used.\n * @param props.apiOnSuccess - A callback to run when an API\n *   request is successful. If not provided, the default behavior will be used.\n * @param props.apiOnError - A callback to run when an API\n *   request fails. If not provided, the default behavior will be used.\n * @param props.isDevTools - Whether to render the React Query devtools.\n *   Defaults to `false`.\n * @param props.devToolsOptions - Options to pass to the\n *   React Query devtools.\n * @param props.toast - Options for the\n *   `toast` utility from `react-hot-toast`.\n *   See the [documentation](https://react-hot-toast.com/docs) for more details.\n *\n *   The `wrapper` property can be used to customize the toast component.\n *\n *   The `globalProps` property can be used to customize the default props for the toast component.\n *\n *   The `ToastCustomUndoContent` property can be used to customize the content of the toast when the user\n *   clicks the \"UNDO\" button.\n */\nexport function RQWrapper({\n  children,\n  config = {},\n  apiUrl,\n  apiClient = fetcher,\n  apiEnsureTrailingSlash = false,\n  apiAuthorization,\n  apiHeaders,\n  apiOnSuccess,\n  apiOnError,\n  isDevTools,\n  devToolsOptions,\n  toast: toastProps,\n}: {\n  children: ReactNode;\n  config?: QueryClientConfig;\n  apiUrl: string;\n  apiClient?: ApiClient;\n  apiAuthorization?: () => string;\n  apiHeaders?: () => ApiProps['headers'];\n  apiOnSuccess?: ApiProps['onSuccess'];\n  apiOnError?: ApiProps['onError'];\n  apiEnsureTrailingSlash?: boolean;\n  isDevTools?: boolean;\n  devToolsOptions?: ReactQueryDevtoolsProps;\n  toast?: {\n    globalProps?: ToastProps;\n    CustomContent?: ToastCustomContent;\n    CustomUndoContent?: ToastCustomUndoContent;\n  };\n}) {\n  const queryClient = useMemo(() => {\n    const client = new QueryClient({\n      ...config,\n    });\n\n    queryClientManager.queryClient = client;\n\n    return client;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const fetch = useCallback<ApiClient>((args) => {\n    const globalAuthorization = apiAuthorization ? apiAuthorization() : '';\n    const globalHeaders = apiHeaders ? apiHeaders() : {};\n\n    const onSuccess: ApiProps['onSuccess'] = (...successArgs) => {\n      if (apiOnSuccess) {\n        apiOnSuccess(...successArgs);\n      }\n\n      if (args.onSuccess) {\n        args.onSuccess(...successArgs);\n      }\n    };\n\n    const onError: ApiProps['onError'] = (...errorArgs) => {\n      if (apiOnError) {\n        apiOnError(...errorArgs);\n      }\n\n      if (args.onError) {\n        args.onError(...errorArgs);\n      }\n    };\n\n    return apiClient({\n      ...args,\n      headers: args.headers ? {\n        ...globalHeaders,\n        ...args.headers,\n      } : globalHeaders,\n      authorization: args.authorization || globalAuthorization,\n      onSuccess,\n      onError,\n    });\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const toastUndo = useCallback<RQWrapperContextProps['toastUndo']>((data) => {\n    let isSuccess = false;\n\n    toast.dismiss();\n\n    const onUndo = () => {\n      isSuccess = true;\n      undoEventEmitter.emit('end', true);\n      toast.dismiss();\n    };\n\n    if (!IS_TEST_ENV) {\n      toast.success(\n        (t) => {\n          const CustomContent = toastProps?.CustomUndoContent;\n\n          if (!t.visible && !isSuccess) {\n            isSuccess = true;\n            undoEventEmitter.emit('end', false);\n          }\n\n          return CustomContent\n            ? (\n                <CustomContent\n                  message={data.message}\n                  onUndo={onUndo}\n                  type={data.type}\n                  toast={t}\n                />\n              )\n            : (\n                <>\n                  {data.message}\n\n                  <span\n                    style={{ marginLeft: '10px', cursor: 'pointer' }}\n                    onClick={onUndo}\n                    role=\"button\"\n                    tabIndex={0}\n                    aria-label=\"Undo\"\n                    title=\"Undo\"\n                  >\n                    UNDO\n                  </span>\n                </>\n              );\n        },\n        {\n          duration: toastProps?.globalProps?.toastOptions?.duration || 5000,\n        },\n      );\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const contextValue = useMemo<RQWrapperContextProps>(() => ({\n    apiUrl: removeFirstAndLastSlash(apiUrl),\n    apiClient: fetch,\n    apiEnsureTrailingSlash,\n    toastUndo,\n  }), [apiUrl, fetch, toastUndo, apiEnsureTrailingSlash]);\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      {!IS_TEST_ENV && (\n        <Toaster {...toastProps?.globalProps}>\n          {toastProps?.CustomContent}\n        </Toaster>\n      )}\n\n      <Context.Provider value={contextValue}>\n        {children}\n      </Context.Provider>\n\n      {isDevTools && (\n        <ReactQueryDevtools\n          buttonPosition=\"bottom-right\"\n          initialIsOpen={false}\n          {...devToolsOptions}\n        />\n      )}\n    </QueryClientProvider>\n  );\n}\n","import React, { useCallback } from 'react';\nimport { type ToasterProps, type ToastPosition } from 'react-hot-toast';\nimport { resolveValue, useToaster } from 'react-hot-toast/headless';\n\nconst prefersReducedMotion = (() => {\n  let shouldReduceMotion: boolean | undefined;\n\n  return () => {\n    // @ts-ignore\n    if (shouldReduceMotion === undefined && typeof window !== 'undefined' && window.matchMedia) {\n      const mediaQuery = matchMedia('(prefers-reduced-motion: reduce)');\n      shouldReduceMotion = !mediaQuery || mediaQuery.matches;\n    }\n    return shouldReduceMotion;\n  };\n})();\n\nfunction ToastWrapper({\n  id,\n  className,\n  style,\n  onHeightUpdate,\n  children,\n}: {\n  id: string;\n  className?: string;\n  style?: React.CSSProperties;\n  onHeightUpdate: (id: string, height: number) => void;\n  children?: React.ReactNode;\n}) {\n  const ref = useCallback(\n    (el: HTMLElement | null) => {\n      if (el) {\n        const updateHeight = () => {\n          const { height } = el.getBoundingClientRect();\n          onHeightUpdate(id, height);\n        };\n        updateHeight();\n        new MutationObserver(updateHeight).observe(el, {\n          subtree: true,\n          childList: true,\n          characterData: true,\n        });\n      }\n    },\n    [id, onHeightUpdate],\n  );\n\n  return (\n    <div data-toast-id={id} ref={ref} className={className} style={style}>\n      {children}\n    </div>\n  );\n}\n\nconst getPositionStyle = (\n  position: ToastPosition,\n  offset: number,\n): React.CSSProperties => {\n  const top = position.includes('top');\n  const verticalStyle: React.CSSProperties = top ? { top: 0 } : { bottom: 0 };\n  const horizontalStyle: React.CSSProperties = position.includes('center')\n    ? { justifyContent: 'center' }\n    : position.includes('right')\n      ? { justifyContent: 'flex-end' }\n      : {};\n\n  return {\n    left: 0,\n    right: 0,\n    display: 'flex',\n    position: 'absolute',\n    transition: prefersReducedMotion()\n      ? undefined\n      : 'all 230ms cubic-bezier(.21,1.02,.73,1)',\n    transform: `translateY(${offset * (top ? 1 : -1)}px)`,\n    ...verticalStyle,\n    ...horizontalStyle,\n  };\n};\n\nconst DEFAULT_OFFSET = 16;\n\nexport function Toaster({\n  reverseOrder,\n  position = 'top-center',\n  toastOptions,\n  gutter,\n  children,\n  containerStyle,\n  containerClassName,\n}: ToasterProps) {\n  const { toasts, handlers } = useToaster(toastOptions);\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        zIndex: 9999,\n        top: DEFAULT_OFFSET,\n        left: DEFAULT_OFFSET,\n        right: DEFAULT_OFFSET,\n        bottom: DEFAULT_OFFSET,\n        pointerEvents: 'none',\n        ...containerStyle,\n      }}\n      className={containerClassName}\n      onMouseEnter={handlers.startPause}\n      onMouseLeave={handlers.endPause}\n    >\n      {toasts.map((t) => {\n        const toastPosition = t.position || position;\n        const toast = { ...t, position: toastPosition };\n\n        const offset = handlers.calculateOffset(toast, {\n          reverseOrder,\n          gutter,\n          defaultPosition: position,\n        });\n        const positionStyle = getPositionStyle(toastPosition, offset);\n\n        const Component = children;\n\n        return (\n          <ToastWrapper\n            id={toast.id}\n            key={toast.id}\n            onHeightUpdate={handlers.updateHeight}\n            style={{\n              ...positionStyle,\n              pointerEvents: 'auto',\n            }}\n          >\n            {toast.type === 'custom' ? (\n              resolveValue(t.message, toast)\n            ) : Component ? (\n              <Component {...toast} />\n            ) : (\n              <div style={{ display: t.visible ? 'flex' : 'none' }}>\n                {resolveValue(toast.message, toast)}\n              </div>\n            )}\n          </ToastWrapper>\n        );\n      })}\n    </div>\n  );\n}\n","import toastApi, { Renderable, ToastPosition } from 'react-hot-toast/headless';\nimport { type Toast, ToastBar as ToastBarToast, resolveValue } from 'react-hot-toast';\nimport React from 'react';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst { remove, ...restOfToastApi } = toastApi;\n\n/** @notExported */\ninterface ToastBarProps {\n  toast: Toast;\n  position?: ToastPosition;\n  style?: React.CSSProperties;\n  children?: (components: {\n      icon: Renderable;\n      message: Renderable;\n  }) => Renderable;\n}\n\n/**\n * Export of `toast` from `react-hot-toast/headless`, which is an API for creating notifications,\n *\n * ⚠️ but without the **`remove`** method ⚠️.\n *\n * See the [documentation](https://react-hot-toast.com/docs/toast) for more details.\n */\nexport const toast = Object.assign(\n  (...args: Parameters<typeof toastApi>) => toastApi(...args),\n  restOfToastApi,\n);\n\n/**\n * `ToastBar` is a wrapper for displaying notifications from the `react-hot-toast` library.\n * You can use it or create your own implementation. See the [documentation](https://react-hot-toast.com/docs/toast-bar) for more details.\n */\nexport const ToastBar: React.FC<ToastBarProps> = ToastBarToast;\n\n/**\n * A utility function that resolves the value of a toast message. The value can either be a static value or a function\n * that generates the value based on the provided argument.\n *\n * @example\n * // Resolving a static value\n * const message = resolveToastValue('Hello, World!', toast);\n *\n * @example\n * // Resolving a value from a function\n * const message = resolveToastValue((ctx) => `Hello, ${ctx.userName}!`, toast);\n */\nexport const resolveToastValue = resolveValue;\n","import EventEmitter from 'eventemitter3';\n\nconst eventEmitter = new EventEmitter();\n\nexport const undoEventEmitter = {\n  /**\n   * Listens for the next 'end' event and then removes the listener.\n   *\n   * @param type The type of event to listen for. Currently only 'end' is supported.\n   * @param callback The callback function to be called when the event is emitted. The callback will receive a boolean indicating whether the event was triggered by an undo action.\n   * @return A function that can be called to remove the listener.\n   */\n  once: (type: 'end', callback: (isUndo: boolean) => void) => {\n    eventEmitter.once(type, callback);\n  },\n  /**\n   * Emits an 'end' event, which is used to let any registered callbacks know that an undo/redo action has completed.\n   *\n   * @param type The type of event to emit. Currently only 'end' is supported.\n   * @param isUndo A boolean indicating whether the event was triggered by an undo action.\n   */\n  emit: (type: 'end', isUndo: boolean) => {\n    eventEmitter.emit(type, isUndo);\n  },\n};\n","// TODO\nexport const IS_TEST_ENV = process.env.NODE_ENV === 'test';\n","import { QueryClient } from '@tanstack/react-query';\n\nexport const queryClientManager: {\n  queryClient: QueryClient;\n} = {\n  queryClient: {} as QueryClient,\n};\n\nexport const getQueryClient = () => {\n  return queryClientManager.queryClient;\n};\n","import { InfiniteData, useInfiniteQuery } from '@tanstack/react-query';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport {\n  ApiProps, QueryResponse, QueryInfiniteListKey,\n  QueryInfinitePagination,\n  Resource, UseInfiniteQueryProps,\n} from '../type';\nimport { CustomError } from '../utils/custom-error';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\n\n/**\n * A hook that helps you fetch a infinite list of resources.\n *\n * The hook uses `useInfiniteQuery` from `@tanstack/react-query` to fetch data and cache it.\n * It accepts various query options and performs an API request to fetch a list of resources\n * based on the provided `resource` and `params`. The hook supports additional query parameters\n * and custom API client parameters.\n *\n * If a custom `queryFn` is provided, it will be used to perform the query; otherwise,\n * the default API client method will be used. The `queryKey` is constructed based on\n * the resource path and additional parameters to ensure proper caching and refetching.\n *\n * By default, this hook sets the following options:\n * - `initialPageParam`: 1\n * - `getNextPageParam`: Calculates the next page number based on the length of the data in the last page.\n * - `getPreviousPageParam`: Calculates the previous page number, but prevents it from going below 1.\n *\n * These default options can be overridden if necessary.\n *\n * @example\n * import { useGetInfiniteList } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * const PATH = 'users/{id}/messages';\n *\n * const infiniteQuery = useGetInfiniteList<typeof PATH, TData>({\n *   resource: { path: PATH, params: { id: 10 } },\n *   pagination: { page: ['page_number'], per_page: ['count', 20] },\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n *\n * @param options - The options object for configuring the hook.\n * @param options.queryOptions - Additional options to configure the `useInfiniteQuery` hook.\n * @param options.resource - The resource path and any static parameters for the API request.\n * @param options.params - Dynamic query parameters for the API request.\n * @param options.apiClientParams - Additional options to pass to the API client.\n * @param options.pagination - The pagination configuration.\n *\n * - **`page`** - An array where the first element is the name of the query parameter that represents the page number. The page number will automatically increment with each subsequent request.\n *\n * - **`per_page`** - An array where the first element is the name of the query parameter that represents the number of items per page, and the second element is the value to be used for that parameter.\n *\n * For example:\n *\n * - **`{ page: ['page_number'], per_page: ['count', 20] }`** will result in query parameters like **`?page_number={{pageParam}}&count=20`**.\n *\n * @returns The result of the `useInfiniteQuery` hook.\n */\nexport const useGetInfiniteList = <TPath extends string, TData = any>({\n  queryOptions,\n  resource,\n  params = {},\n  apiClientParams,\n  pagination,\n}: {\n  queryOptions?: UseInfiniteQueryProps<\n    QueryResponse<TData[]>,\n    QueryInfiniteListKey<TPath>,\n    {\n      resource: Resource<TPath>;\n      params: QueryInfiniteListKey<TPath>['4'];\n      queryKey: QueryInfiniteListKey<TPath>;\n    }\n  >;\n  resource: Resource<TPath>;\n  params?: QueryInfiniteListKey<TPath>['4'];\n  apiClientParams?: Partial<ApiProps>;\n  pagination: QueryInfinitePagination;\n}) => {\n  const { apiUrl, apiClient, apiEnsureTrailingSlash } = useRQWrapperContext();\n\n  const query = useInfiniteQuery<\n    QueryResponse<TData[]>,\n    CustomError,\n    InfiniteData<QueryResponse<TData[]>>,\n    QueryInfiniteListKey<TPath>\n  >({\n    initialPageParam: 1,\n    getNextPageParam: (...args) => {\n      const lastPage = args[0];\n      const lastPageParam = Number(args[2]);\n\n      if (!lastPage?.data?.length) {\n        return undefined;\n      }\n\n      return lastPageParam + 1;\n    },\n    getPreviousPageParam: (...args) => {\n      const firstPageParam = Number(args[2]);\n\n      if (firstPageParam <= 1) {\n        return undefined;\n      }\n\n      return firstPageParam - 1;\n    },\n    ...queryOptions,\n    queryKey: [\n      'get-infinite-list',\n      resource.path,\n      resource.params,\n      pagination,\n      params,\n      ...(queryOptions?.queryKey ? queryOptions.queryKey : []),\n    ] as QueryInfiniteListKey<TPath>,\n    queryFn: async ({ queryKey, pageParam }) => {\n      const variables = {\n        resource,\n        params: {\n          ...params,\n          [pagination.page[0]]: pageParam,\n          [pagination.per_page[0]]: pagination.per_page[1],\n        },\n        queryKey,\n      };\n\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, apiEnsureTrailingSlash)}`;\n\n      if (queryOptions?.queryFn) {\n        const results = await queryOptions?.queryFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const result = await apiClient({\n        url,\n        method: 'GET',\n        params: variables.params,\n        ...apiClientParams,\n      });\n\n      return result;\n    },\n  });\n\n  return query;\n};\n","import { useQuery } from '@tanstack/react-query';\nimport {\n  Resource,\n  UseQueryProps,\n  QueryResponse,\n  QueryOneKey,\n  ApiProps,\n} from '../type';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { CustomError } from '../utils/custom-error';\n\n/**\n * A hook that helps you fetch a single resource.\n *\n * The hook uses `useQuery` from `@tanstack/react-query` to fetch data and cache it.\n * It accepts various query options and performs the API request to fetch the resource\n * identified by the given `id`. The hook supports additional query parameters and custom\n * API client parameters.\n *\n * If a custom `queryFn` is provided, it will be used to perform the query; otherwise,\n * the default API client method will be used. The `queryKey` is constructed based on\n * the resource path, ID, and other optional parameters to ensure proper caching and\n * refetching.\n *\n * @example\n * import { useGetOne } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * const PATH = 'users/{id}/messages';\n *\n * const queryOne = useGetOne<typeof PATH, TData>({\n *   resource: { path: PATH, params: { id: 1 } },\n *   id: 123,\n *   queryOptions: {\n *     onSuccess: (data) => {\n *       console.log('Data fetched successfully:', data);\n *     },\n *   },\n *   params: { include: 'details' },\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n *\n * @param params The parameters for the hook.\n * @param params.queryOptions - Additional options to configure the `useQuery`\n * @param params.resource - The resource path and any static parameters for the API request.\n * @param params.params - Dynamic query parameters for the API request.\n * @param params.apiClientParams - Additional options to pass to the API client.\n */\nexport const useGetOne = <TPath extends string, TData = any>({\n  resource,\n  id,\n  queryOptions,\n  params = {},\n  apiClientParams,\n}: {\n  resource: Resource<TPath>;\n  id: string | number;\n  queryOptions?: UseQueryProps<\n    QueryResponse<TData>,\n    QueryOneKey<TPath>,\n    {\n      resource: Resource<TPath>;\n      id: string | number;\n      params: QueryOneKey<TPath>['4'];\n      queryKey: QueryOneKey<TPath>;\n    }\n  >;\n  params?: QueryOneKey<TPath>['4'];\n  apiClientParams?: Partial<ApiProps>;\n}) => {\n  const { apiUrl, apiClient, apiEnsureTrailingSlash } = useRQWrapperContext();\n\n  const query = useQuery<\n    QueryResponse<TData>,\n    CustomError,\n    QueryResponse<TData>,\n    QueryOneKey<TPath>\n  >({\n    ...queryOptions,\n    queryKey: [\n      'get-one',\n      resource.path,\n      resource.params,\n      String(id),\n      params,\n      ...(queryOptions?.queryKey ? queryOptions.queryKey : []),\n    ] as QueryOneKey<TPath>,\n    queryFn: async ({ queryKey }) => {\n      const variables = {\n        id, resource, params, queryKey,\n      };\n\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, true)}`;\n\n      if (queryOptions?.queryFn) {\n        const results = await queryOptions?.queryFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const result = await apiClient({\n        url: `${url}${variables.id}${apiEnsureTrailingSlash ? '/' : ''}`,\n        method: 'GET',\n        params,\n        ...apiClientParams,\n      });\n\n      return result;\n    },\n  });\n\n  return query;\n};\n","import { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useRef } from 'react';\nimport {\n  MutateMode,\n  Resource,\n  UseMutateProps,\n  QueryResponse,\n  MutationMode,\n  MutateKey,\n  ApiProps,\n} from '../type';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { CustomError } from '../utils/custom-error';\nimport { Snapshot } from '../internal/type';\nimport { deleteItemsFromQueryCache, helpersQueryKeys, invalidateQueries } from '../utils/queries';\nimport { undoEventEmitter } from '../internal/utils/undo-event-emitter';\nimport { createSnapshot } from '../internal/utils/create-snapshot';\nimport { IS_TEST_ENV } from '../internal/env';\n\n/** @notExported */\ntype MutateBaseVariables<TPath extends string, TType, TExtraData> = (\n  TType extends 'many' ? {\n    ids: (string | number)[];\n    resource: Resource<TPath>;\n    apiClientParams?: Partial<ApiProps>;\n    extraData?: TExtraData;\n  } : {\n    id: string | number;\n    resource: Resource<TPath>;\n    apiClientParams?: Partial<ApiProps>;\n    extraData?: TExtraData;\n  }\n);\n\n/** @notExported */\ntype DeleteBaseVariables<TPath extends string, TType, TExtraData> = (\n  Omit<MutateBaseVariables<TPath, TType, TExtraData>, 'resource'> & {\n    resourceParams: Resource<TPath>['params'];\n    undoMessage?: string;\n  }\n);\n\n/** @notExported */\ntype DeleteBase<\n  TPath extends string,\n  TData = any,\n  TType extends MutationMode = 'many',\n  TExtraData = any,\n> = {\n  resourcePath: Resource<TPath>['path'];\n  mutationOptions?: UseMutateProps<\n    TType extends 'many' ? QueryResponse<TData>[] : QueryResponse<TData>,\n    MutateBaseVariables<TPath, TType, TExtraData>\n  >;\n  mode?: MutateMode;\n  extraResources?: Resource<any>[];\n  shouldUpdateCurrentResource?: boolean;\n  isInvalidateCache?: boolean;\n  type: TType;\n};\n\nconst useDeleteBase = <\n  TPath extends string,\n  TData = any,\n  TType extends MutationMode = 'many',\n  TExtraData = any,\n>({\n    resourcePath,\n    mutationOptions,\n    mode = {\n      optimistic: true,\n      undoable: true,\n    },\n    extraResources = [],\n    shouldUpdateCurrentResource = true,\n    isInvalidateCache = true,\n    type = 'many' as TType,\n  }: DeleteBase<TPath, TData, TType, TExtraData>) => {\n  const {\n    apiUrl, apiClient, apiEnsureTrailingSlash, toastUndo,\n  } = useRQWrapperContext();\n  const queryClient = useQueryClient();\n\n  const snapshot = useRef<Snapshot>([]);\n  const backToSnapshot = () => {\n    snapshot.current.forEach(([key, value]) => {\n      queryClient.setQueryData(key, value);\n    });\n  };\n\n  const { mutate, ...mutation } = useMutation<\n    TType extends 'many' ? QueryResponse<TData>[] : QueryResponse<TData>,\n    CustomError,\n    MutateBaseVariables<TPath, TType, TExtraData>\n  >({\n    ...mutationOptions,\n    mutationKey: [\n      type === 'many' ? 'delete-many' : 'delete-one',\n      resourcePath,\n      ...(mutationOptions?.mutationKey ? mutationOptions.mutationKey : []),\n    ] as MutateKey<TPath>,\n    mutationFn: async (variables) => {\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, true)}`;\n\n      if (mutationOptions?.mutationFn) {\n        const results = await mutationOptions?.mutationFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const ids = type === 'many'\n        ? (variables as MutateBaseVariables<TPath, 'many', TExtraData>).ids\n        : [(variables as MutateBaseVariables<TPath, 'one', TExtraData>).id];\n\n      const actions = await Promise.allSettled(ids.map((id) => apiClient<TData>({\n        url: `${url}${id}${apiEnsureTrailingSlash ? '/' : ''}`,\n        method: 'DELETE',\n        ...variables.apiClientParams,\n      })));\n\n      const result: QueryResponse<TData>[] = [];\n\n      actions.forEach((response) => {\n        if (response.status === 'fulfilled') {\n          result.push(response.value);\n        } else {\n          throw response.reason;\n        }\n      });\n\n      return (type === 'many' ? result : result[0]) as any;\n    },\n    onSuccess: (...rest) => {\n      const variables = rest[1];\n\n      const queryKeys = [\n        helpersQueryKeys.getList(variables.resource),\n        helpersQueryKeys.getInfiniteList(variables.resource),\n      ];\n\n      extraResources.forEach((extResource) => {\n        queryKeys.push(helpersQueryKeys.getList(extResource));\n        queryKeys.push(helpersQueryKeys.getInfiniteList(extResource));\n      });\n\n      if (isInvalidateCache) {\n        invalidateQueries({ queryKeys });\n      }\n\n      if (mutationOptions?.onSuccess) {\n        mutationOptions.onSuccess(...rest);\n      }\n    },\n    onError: (...rest) => {\n      if (mutationOptions?.onError) {\n        mutationOptions.onError(...rest);\n      }\n\n      backToSnapshot();\n    },\n  });\n\n  const deleteBase = async ({ resourceParams, undoMessage, ...variables }: DeleteBaseVariables<TPath, TType, TExtraData>) => {\n    const resource: Resource<TPath> = {\n      path: resourcePath,\n      params: resourceParams,\n    };\n\n    const ids = type === 'many'\n      ? (variables as any as DeleteBaseVariables<TPath, 'many', TExtraData>).ids\n      : [(variables as any as DeleteBaseVariables<TPath, 'one', TExtraData>).id];\n\n    if (mode.optimistic) {\n      const queryKeysOne = shouldUpdateCurrentResource ? helpersQueryKeys.getOneArray(resource, ids) : [];\n      const queryKeysList = shouldUpdateCurrentResource ? [helpersQueryKeys.getList(resource)] : [];\n      const queryKeysInfiniteList = shouldUpdateCurrentResource ? [helpersQueryKeys.getInfiniteList(resource)] : [];\n\n      extraResources.forEach((extResource) => {\n        queryKeysOne.push(...helpersQueryKeys.getOneArray(extResource, ids));\n        queryKeysList.push(helpersQueryKeys.getList(extResource));\n        queryKeysInfiniteList.push(helpersQueryKeys.getInfiniteList(extResource));\n      });\n\n      snapshot.current = await createSnapshot([\n        ...queryKeysOne,\n        ...queryKeysList,\n        ...queryKeysInfiniteList,\n      ]);\n\n      deleteItemsFromQueryCache({\n        ids,\n        queryKeysOne,\n        queryKeysList,\n        queryKeysInfiniteList,\n      });\n    }\n\n    if (mode.undoable && !IS_TEST_ENV) {\n      const isMany = ids.length > 1;\n\n      undoEventEmitter.once('end', (isUndo) => {\n        if (isUndo) {\n          backToSnapshot();\n        } else {\n          mutate({ ...variables, resource } as any);\n        }\n      });\n\n      toastUndo({\n        message: undoMessage || `Element${isMany ? 's' : ''} deleted`,\n        type: isMany ? 'delete-many' : 'delete-one',\n      });\n    } else {\n      mutate({ ...variables, resource } as any);\n    }\n  };\n\n  return {\n    mutation,\n    delete: deleteBase,\n  };\n};\n\n/**\n * A hook that helps you delete a single resource.\n *\n * The hook uses `useMutation` from `@tanstack/react-query` under the hood, so it accepts all the same options.\n * It performs an optimistic update by removing the resource from the cache before\n * the deletion request is sent. If the deletion fails, the resource is restored in the cache.\n *\n * If the `undoable` mode is enabled, the hook allows the deletion to be undone within a certain\n * period of time. If the undo action is not performed, the resource will be permanently deleted.\n *\n * @example\n * import { useDeleteOne } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * const PATH = 'users/{id}/messages';\n *\n * const { delete: deleteOne } = useDeleteOne<typeof PATH, TData>({\n *   resourcePath: PATH,\n * });\n *\n * deleteOne({\n *   id: 123,\n *   resourceParams: { id: 1 },\n *   undoMessage: 'Message deleted',\n * });\n *\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n *\n * @param props - The options for the hook.\n * @returns An object with properties, `delete` and `mutation`.\n *\n * `delete` is a function that takes the ID and params of the resource to delete,\n * and calls the mutation function with the necessary data.\n *\n * `mutation` is result `useMutation` without propery `mutate`\n */\nexport const useDeleteOne = <\n  TPath extends string,\n  TData = any,\n  TExtraData = any,\n>(props: Omit<DeleteBase<TPath, TData, 'one', TExtraData>, 'type'>) => {\n  return useDeleteBase({ ...props, type: 'one' });\n};\n\n/**\n * A hook that helps you delete multiple resources at once.\n *\n * The hook uses `useMutation` from `@tanstack/react-query under the hood, so it accepts all the same options.\n * It performs an optimistic update by removing the resources from the cache before\n * the deletion requests are sent. If any deletion fails, the resources are restored in the cache.\n *\n * If the `undoable` mode is enabled, the hook allows the deletions to be undone within a certain\n * period of time. If the undo action is not performed, the resources will be permanently deleted.\n *\n * @example\n * import { useDeleteMany } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * const PATH = 'users/{id}/messages';\n *\n * const { delete: deleteMany } = useDeleteMany<typeof PATH, TData>({\n *   resourcePath: PATH,\n * });\n *\n * deleteMany({\n *   ids: [123, 456],\n *   resourceParams: { id: 1 },\n *   undoMessage: 'Messages deleted',\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n *\n * @param props - The options for the hook.\n * @returns An object with properties, `delete` and `mutation`.\n *\n * `delete` is a function that takes the ID and params of the resource to delete,\n * and calls the mutation function with the necessary data.\n *\n * `mutation` is result `useMutation` without propery `mutate`\n */\nexport const useDeleteMany = <\n  TPath extends string,\n  TData = any,\n  TExtraData = any,\n>(props: Omit<DeleteBase<TPath, TData, 'many', TExtraData>, 'type'>) => {\n  return useDeleteBase({ ...props, type: 'many' });\n};\n","import { getQueryClient } from '../../internal/query-client';\nimport { OnlyObject, QueryOneKey } from '../../type';\n\n/**\n * Adds an item to the query cache based on provided data and cache keys.\n *\n * @template TData - The type of data stored in the cache.\n * @param params - The parameters for the function.\n * @param params.data - The new data to add to the corresponding items.\n * @param params.queryKeysOne - Cache keys for single queries that should be updated.\n *\n * @example\n * addItemFromQueryCache({\n *   data: { name: 'New Item' },\n *   queryKeysOne: [['get-one', 'posts', {}, '1']],\n * });\n */\nexport const addItemToQueryCache = ({\n  data,\n  queryKeysOne,\n}: {\n  data: OnlyObject;\n  queryKeysOne?: [QueryOneKey<''>[0], ...any[]][];\n}) => {\n  const queryClient = getQueryClient();\n\n  if (queryKeysOne) {\n    queryKeysOne.forEach((queryKeyOne) => {\n      queryClient.setQueryData(queryKeyOne, data);\n    });\n  }\n};\n","import { InfiniteData } from '@tanstack/react-query';\nimport {\n  OnlyObject, QueryInfiniteListKey, QueryListKey,\n  QueryResponse,\n} from '../../type';\nimport { getQueryClient } from '../../internal/query-client';\n\n/**\n * Adds items to the query cache for list and infinite list queries.\n *\n * @example\n * addItemsToListQueryCache({\n *   data: [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }],\n *   queryKeysList: [['get-list', 'posts', {}]],\n *   queryKeysInfiniteList: [['get-infinite-list', 'posts', {}]],\n *   cacheAddItemTo: 'end'\n * });\n */\nexport const addItemsToListQueryCache = ({\n  data,\n  queryKeysList,\n  queryKeysInfiniteList,\n  cacheAddItemTo = 'start',\n}: {\n  data: OnlyObject[];\n  queryKeysList?: [QueryListKey<''>[0], ...OnlyObject[]][];\n  queryKeysInfiniteList?: [QueryInfiniteListKey<''>[0], ...OnlyObject[]][];\n  cacheAddItemTo?: 'end' | 'start';\n}) => {\n  const queryClient = getQueryClient();\n\n  const updateListData = (page: QueryResponse<OnlyObject[]> | undefined) => {\n    if (!page || !(page.data instanceof Array)) { return page; }\n\n    return {\n      ...page,\n      data: cacheAddItemTo === 'start'\n        ? [...data, ...page.data]\n        : [...page.data, ...data],\n    };\n  };\n\n  if (queryKeysList) {\n    queryKeysList.forEach((queryKey) => {\n      queryClient.setQueriesData<QueryResponse<OnlyObject[]>>(\n        { queryKey },\n        updateListData,\n      );\n    });\n  }\n\n  if (queryKeysInfiniteList) {\n    queryKeysInfiniteList.forEach((queryKey) => {\n      queryClient.setQueriesData<InfiniteData<QueryResponse<OnlyObject[]> | undefined>>(\n        { queryKey },\n        (old) => {\n          if (!old) { return old; }\n\n          return {\n            ...old,\n            pages: old.pages.map(updateListData),\n          };\n        },\n      );\n    });\n  }\n};\n","import { getQueryClient } from '../../internal/query-client';\n\n/**\n * Remove queries in the cache that have a key matching any of the specified `queryKeys`.\n *\n * @param params\n * @param params.queryKeys - An array of arrays of keys for which the corresponding queries should be removed.\n *\n * @example\n * removeQueries({\n *   queryKeys: [\n *     ['get-list', 'path'],\n *     ['get-one', 'path', '1'],\n *   ],\n * });\n *\n * @returns {void} - This function does not return a value.\n */\nexport const removeQueries = ({\n  queryKeys,\n}: {\n  queryKeys: any[][],\n}) => {\n  const queryClient = getQueryClient();\n\n  queryKeys.forEach((queryKey) => {\n    queryClient.removeQueries({ queryKey });\n  });\n};\n","import { InfiniteData } from '@tanstack/react-query';\nimport {\n  QueryResponse,\n  QueryInfiniteListKey,\n  QueryListKey,\n  QueryOneKey,\n} from '../../type';\nimport { removeQueries } from './remove-queries';\nimport { getQueryClient } from '../../internal/query-client';\n\n/**\n * Deletes items from the query cache based on provided IDs.\n *\n * @template TData - The type of data stored in the cache.\n * @param params - The parameters for the function.\n * @param params.ids - The array of item IDs to delete from the cache.\n * @param params.queryKeysOne - Cache keys for single queries that should be deleted.\n * @param params.queryKeysList - Cache keys for list queries from which items should be deleted.\n * @param params.queryKeysInfiniteList - Cache keys for infinite list queries from which items should be deleted.\n *\n * @example\n * deleteItemsFromQueryCache({\n *   ids: [1, 2, 3],\n *   queryKeysOne: [['get-one', 'posts', {}, '1']],\n *   queryKeysList: [['get-list', 'posts', {}]],\n *   queryKeysInfiniteList: [['get-infinite-list', 'posts', {}]]\n * });\n */\nexport const deleteItemsFromQueryCache = <TData = any>({\n  ids,\n  queryKeysOne,\n  queryKeysList,\n  queryKeysInfiniteList,\n}: {\n  ids: (string | number)[];\n  queryKeysOne?: [QueryOneKey<''>[0], ...any[]][];\n  queryKeysList?: [QueryListKey<''>[0], ...any[]][];\n  queryKeysInfiniteList?: [QueryInfiniteListKey<''>[0], ...any[]][];\n}) => {\n  const queryClient = getQueryClient();\n\n  const updateListData = (page: QueryResponse<TData[]> | undefined) => {\n    if (!page || !(page.data instanceof Array)) { return page; }\n\n    return {\n      ...page,\n      data: page.data.filter((item: any) => {\n        return !ids.some((id) => String(id) === String(item.id));\n      }),\n    };\n  };\n\n  if (queryKeysOne) {\n    removeQueries({ queryKeys: queryKeysOne });\n  }\n\n  if (queryKeysList) {\n    queryKeysList.forEach((queryKey) => {\n      queryClient.setQueriesData<QueryResponse<TData[]>>(\n        { queryKey },\n        updateListData,\n      );\n    });\n  }\n\n  if (queryKeysInfiniteList) {\n    queryKeysInfiniteList.forEach((queryKey) => {\n      queryClient.setQueriesData<InfiniteData<QueryResponse<TData[]> | undefined>>(\n        { queryKey },\n        (old) => {\n          if (!old) { return old; }\n\n          return {\n            ...old,\n            pages: old.pages.map(updateListData),\n          };\n        },\n      );\n    });\n  }\n};\n","import {\n  QueryDataKey,\n  QueryInfiniteListKey,\n  QueryListKey,\n  QueryOneKey,\n  Resource,\n  TakeFirstKeys,\n} from '../../type';\n\n/**\n * A utility object for generating query keys used in React Query.\n */\nexport const helpersQueryKeys = {\n  /**\n   * Generates a query key for fetching a single item by ID.\n   *\n   * @param itemResource - The resource object containing the path and parameters for the query.\n   * @param id - The ID of the item to fetch.\n   * @returns The query key for the single item.\n   *\n   * @example\n   * const key = helpersQueryKeys.getOne(resource, 1);\n   * // key: ['get-one', 'posts', {}, '1']\n   */\n  getOne: (\n    <TPath extends string>(itemResource: Resource<TPath>, id: string | number): TakeFirstKeys<QueryOneKey<any>, 4> => (\n      ['get-one', itemResource.path, itemResource.params, String(id)]\n    )\n  ),\n\n  /**\n   * Generates an array of query keys for fetching multiple items by their IDs.\n   *\n   * @param itemResource - The resource object containing the path and parameters for the query.\n   * @param ids - An array of IDs for the items to fetch.\n   * @returns An array of query keys for the items.\n   *\n   * @example\n   * const keys = helpersQueryKeys.getOneArray(resource, [1, 2]);\n   * // keys: [\n   * //   ['get-one', 'posts', {}, '1'],\n   * //   ['get-one', 'posts', {}, '2']\n   * // ]\n   */\n  getOneArray: (\n    <TPath extends string>(itemResource: Resource<TPath>, ids: (string | number)[]): TakeFirstKeys<QueryOneKey<any>, 4>[] => ids.map((id) => (\n      ['get-one', itemResource.path, itemResource.params, String(id)]\n    ))\n  ),\n\n  /**\n   * Generates a query key for fetching a list of items.\n   *\n   * @param itemResource - The resource object containing the path and parameters for the query.\n   * @returns The query key for the list of items.\n   *\n   * @example\n   * const key = helpersQueryKeys.getList(resource);\n   * // key: ['get-list', 'posts', {}]\n   */\n  getList: (\n    <TPath extends string>(itemResource: Resource<TPath>): TakeFirstKeys<QueryListKey<any>, 3> => (\n      ['get-list', itemResource.path, itemResource.params]\n    )\n  ),\n\n  /**\n   * Generates a query key for fetching an infinite list of items.\n   *\n   * @param itemResource - The resource object containing the path and parameters for the query.\n   * @returns The query key for the infinite list of items.\n   *\n   * @example\n   * const key = helpersQueryKeys.getInfiniteList(resource);\n   * // key: ['get-infinite-list', 'posts', {}]\n   */\n  getInfiniteList: (\n    <TPath extends string>(itemResource: Resource<TPath>): TakeFirstKeys<QueryInfiniteListKey<any>, 3> => (\n      ['get-infinite-list', itemResource.path, itemResource.params]\n    )\n  ),\n\n  /**\n   * Generates a data query key.\n   *\n   * @param itemResource - The resource object containing the path and parameters for the query.\n   * @returns The data query key.\n   *\n   * @example\n   * const key = helpersQueryKeys.getDataQuery(resource);\n   * // key: ['query-data', 'posts', {}]\n   */\n  getDataQuery: (\n    <TPath extends string>(itemResource: Resource<TPath>): TakeFirstKeys<QueryDataKey<any>, 3> => (\n      ['query-data', itemResource.path, itemResource.params]\n    )\n  ),\n};\n","export function isEqual(data1: unknown, data2: unknown): boolean {\n  if (typeof data1 !== typeof data2) {\n    return false;\n  }\n\n  if (data1 instanceof Object && data2 instanceof Object) {\n    const keys1 = Object.keys(data1);\n    const keys2 = Object.keys(data2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const value1 = (data1 as Record<string, unknown>)[key];\n      const value2 = (data2 as Record<string, unknown>)[key];\n\n      if (value1 !== value2 && !isEqual(value1, value2)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (Array.isArray(data1) && Array.isArray(data2)) {\n    if (data1.length !== data2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < data1.length; i++) {\n      if (data1[i] !== data2[i] && !isEqual(data1[i], data2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return data1 === data2;\n}\n","import { getQueryClient } from '../../internal/query-client';\nimport { isEqual } from '../../internal/utils/is-equal';\n\n/**\n * Invalidates queries in the cache that match any of the specified key groups.\n *\n * This function uses the `predicate` option to filter queries whose keys match any of the key groups provided.\n * A query's key is considered a match if it contains all the keys from at least one of the key groups.\n * The function then invalidates all such matching queries using `queryClient.invalidateQueries`.\n *\n * @example\n * import { invalidateMatchingQueries } from 'react-query-manager';\n *\n * // Define key groups where each group is an array of keys that must all be present in the queryKey to be considered a match.\n * const keyGroups = [\n *   ['path', 'get-list'],    // Key group 1\n *   ['path', 'get-one'],  // Key group 2\n * ];\n *\n * // Invalidate queries with keys matching any of the key groups\n * invalidateMatchingQueries({ queryKeys: keyGroups });\n *\n * @param params\n * @param params.queryKeys - An array of arrays, where each inner array represents a group of keys that must all be present\n *                           in a query's key for that query to be invalidated.\n *                           Example: `[['path', 'get-list'], ['path', 'get-one']]`.\n *\n * This function:\n * - Retrieves all cached queries.\n * - Checks if the key of each query matches any of the provided key groups.\n * - Invalidates the queries whose keys match any of the specified key groups.\n *\n * @returns {void} - This function does not return a value.\n */\nexport const invalidateMatchingQueries = ({\n  queryKeys,\n}: {\n  queryKeys: any[][],\n}) => {\n  const queryClient = getQueryClient();\n\n  queryClient.invalidateQueries({\n    predicate: (query) => {\n      const keys = query.queryKey;\n\n      return queryKeys.some((keyGroup) => (\n        keyGroup.every((matchKey) => keys.some((key) => isEqual(key, matchKey)))\n      ));\n    },\n  });\n};\n","import { getQueryClient } from '../../internal/query-client';\nimport { isEqual } from '../../internal/utils/is-equal';\n\n/**\n * Remove queries in the cache that match any of the specified key groups.\n *\n * This function uses the `predicate` option to filter queries whose keys match any of the key groups provided.\n * A query's key is considered a match if it contains all the keys from at least one of the key groups.\n * The function then remove all such matching queries using `queryClient.removeQueries`.\n *\n * @example\n * import { removeMatchingQueries } from 'react-query-manager';\n *\n * // Define key groups where each group is an array of keys that must all be present in the queryKey to be considered a match.\n * const keyGroups = [\n *   ['path', 'get-list'],    // Key group 1\n *   ['path', 'get-one'],  // Key group 2\n * ];\n *\n * // Remove queries with keys matching any of the key groups\n * removeMatchingQueries({ queryKeys: keyGroups });\n *\n * @param params\n * @param params.queryKeys - An array of arrays, where each inner array represents a group of keys that must all be present\n *                           in a query's key for that query to be removed.\n *                           Example: `[['path', 'get-list'], ['path', 'get-one']]`.\n *\n * This function:\n * - Retrieves all cached queries.\n * - Checks if the key of each query matches any of the provided key groups.\n * - Remove the queries whose keys match any of the specified key groups.\n *\n * @returns {void} - This function does not return a value.\n */\nexport const removeMatchingQueries = ({\n  queryKeys,\n}: {\n  queryKeys: any[][],\n}) => {\n  const queryClient = getQueryClient();\n\n  queryClient.removeQueries({\n    predicate: (query) => {\n      const keys = query.queryKey;\n\n      return queryKeys.some((keyGroup) => (\n        keyGroup.every((matchKey) => keys.some((key) => isEqual(key, matchKey)))\n      ));\n    },\n  });\n};\n","import { getQueryClient } from '../../internal/query-client';\n\n/**\n * Invalidates queries in the cache that have a key matching any of the specified `queryKeys`.\n *\n * @param params\n * @param params.queryKeys - An array of arrays of keys for which the corresponding queries should be invalidated.\n *\n * @example\n * invalidateQueries({\n *   queryKeys: [\n *     ['get-list', 'path'],\n *     ['get-one', 'path', '1'],\n *   ],\n * });\n *\n * @returns {void} - This function does not return a value.\n */\nexport const invalidateQueries = ({\n  queryKeys,\n}: {\n  queryKeys: any[][],\n}) => {\n  const queryClient = getQueryClient();\n\n  queryKeys.forEach((queryKey) => {\n    queryClient.invalidateQueries({ queryKey });\n  });\n};\n","/**\n * Checks if a value can be converted to a number.\n *\n * @param value - The value to check.\n * @returns True if the value can be converted to a number, otherwise false.\n */\nfunction isCanConvertToNumber(value: any): boolean {\n  return !Number.isNaN(Number(value));\n}\n\n/**\n * Checks if two values can be coerced to the same type.\n *\n * @param value1 - The first value to check.\n * @param value2 - The second value to check.\n * @returns True if the values can be coerced to the same type (e.g., string to number).\n */\nfunction isCanNumber(value1: any, value2: any): boolean {\n  return isCanConvertToNumber(value1) && isCanConvertToNumber(value2);\n}\n\n/**\n * Recursively merges two objects together, ensuring that only fields that exist\n * and match in type in the target object are merged from the source object.\n *\n * @template TData - The type of the target object.\n * @param target - The target object that will be merged into.\n * @param source - The source object containing values to merge.\n * Only properties that exist in the target object and have matching types will be merged.\n *\n * @returns A new object with the merged values from the target and source objects.\n *\n * @example\n * const target = { id: '1', name: 'Test' };\n * const source = { id: '1', name: 'Test 2', other: 'Ignored' };\n * const result = mergeObjects(target, source);\n * ---> result: { id: '1', name: 'Test 2' }\n */\nexport function mergeObjects<TData extends object>(target: TData, source: any): TData {\n  const result: any = { ...target };\n\n  if (target instanceof Object && source instanceof Object) {\n    for (const key in source) {\n      if (key in target) {\n        const targetValue = (target as any)[key];\n        const sourceValue = source[key];\n\n        const isSameType = typeof targetValue === typeof sourceValue\n          && ((Array.isArray(targetValue) && Array.isArray(sourceValue))\n          || (targetValue !== null && !Array.isArray(targetValue) && typeof targetValue === 'object'\n            && !Array.isArray(sourceValue) && typeof sourceValue === 'object')\n          || (typeof targetValue !== 'object' && typeof sourceValue !== 'object'));\n\n        const canConvertToNumber = isCanNumber(targetValue, sourceValue);\n\n        if (isSameType || canConvertToNumber) {\n          if (typeof targetValue === 'object' && targetValue !== null && !Array.isArray(targetValue)) {\n            result[key] = mergeObjects(targetValue, sourceValue as typeof targetValue);\n          } else {\n            result[key] = sourceValue;\n          }\n        }\n      }\n    }\n  }\n\n  return result as TData;\n}\n","import { InfiniteData } from '@tanstack/react-query';\nimport {\n  QueryResponse,\n  OnlyObject,\n  QueryInfiniteListKey,\n  QueryListKey,\n  QueryOneKey,\n} from '../../type';\nimport { mergeObjects } from '../../internal/utils/merge-objects';\nimport { getQueryClient } from '../../internal/query-client';\n\n/**\n * Updates items in the query cache based on provided IDs and new data.\n *\n * @template TData - The type of data stored in the cache.\n * @param params - The parameters for the function.\n * @param params.data - The new data to update the corresponding items.\n * @param params.ids - The array of item IDs to update.\n * @param params.queryKeysOne - Cache keys for single queries that should be updated.\n * @param params.queryKeysList - Cache keys for list queries that should be updated.\n * @param params.queryKeysInfiniteList - Cache keys for infinite list queries that should be updated.\n *\n * @example\n * updateItemsFromQueryCache({\n *   queryClient,\n *   data: { name: 'Updated Name' },\n *   ids: [1, 2, 3],\n *   queryKeysOne: [['get-one', 'posts', {}, '1']],\n *   queryKeysList: [['get-list', 'posts', {}]],\n *   queryKeysInfiniteList: [['get-infinite-list', 'posts', {}]]\n * });\n */\nexport const updateItemsFromQueryCache = <TData = any>({\n  data,\n  ids,\n  queryKeysOne,\n  queryKeysList,\n  queryKeysInfiniteList,\n}: {\n  data: OnlyObject;\n  ids: (string | number)[];\n  queryKeysOne?: [QueryOneKey<''>[0], ...any[]][];\n  queryKeysList?: [QueryListKey<''>[0], ...any[]][];\n  queryKeysInfiniteList?: [QueryInfiniteListKey<''>[0], ...any[]][];\n}) => {\n  const queryClient = getQueryClient();\n\n  const updateListData = (page: QueryResponse<TData[]> | undefined) => {\n    if (!page || !(page.data instanceof Array)) { return page; }\n\n    return {\n      ...page,\n      data: page.data.map((item: any) => {\n        return ids.some((id) => String(id) === String(item.id))\n          ? mergeObjects(item, data)\n          : item;\n      }),\n    };\n  };\n\n  if (queryKeysOne) {\n    queryKeysOne.forEach((queryKeyOne) => {\n      queryClient.setQueriesData<QueryResponse<TData>>(\n        { queryKey: queryKeyOne },\n        (old) => {\n          if (!old || !(old.data instanceof Object) || !(data instanceof Object)) {\n            return old;\n          }\n\n          return { ...old, data: mergeObjects(old.data, data) };\n        },\n      );\n    });\n  }\n\n  if (queryKeysList) {\n    queryKeysList.forEach((queryKey) => {\n      queryClient.setQueriesData<QueryResponse<TData[]>>(\n        { queryKey },\n        updateListData,\n      );\n    });\n  }\n\n  if (queryKeysInfiniteList) {\n    queryKeysInfiniteList.forEach((queryKey) => {\n      queryClient.setQueriesData<InfiniteData<QueryResponse<TData[]> | undefined>>(\n        { queryKey },\n        (old) => {\n          if (!old) { return old; }\n\n          return {\n            ...old,\n            pages: old.pages.map(updateListData),\n          };\n        },\n      );\n    });\n  }\n};\n","import { getQueryClient } from '../query-client';\nimport { Snapshot } from '../type';\n\n/**\n * Creates a snapshot of the current data in the cache.\n *\n * @param keys The keys to be snapshotted.\n * @returns A snapshot of the current data in the cache.\n */\nexport const createSnapshot = async (keys: any[][]) => {\n  const queryClient = getQueryClient();\n\n  const snapshot: Snapshot = keys.reduce(\n    (prev, queryKey) => prev.concat(queryClient.getQueriesData({ queryKey })),\n    [] as any,\n  );\n\n  // Cancel any outgoing re-fetches (so they don't overwrite our optimistic update)\n  await Promise.all(\n    snapshot.map(([queryKey]) => queryClient.cancelQueries({ queryKey })),\n  );\n\n  return snapshot;\n};\n","import { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useRef } from 'react';\nimport {\n  MutateMode,\n  Resource,\n  UseMutateProps,\n  QueryResponse,\n  OnlyObject,\n  MutationMode,\n  MutateKey,\n  ApiProps,\n} from '../type';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { CustomError } from '../utils/custom-error';\nimport { Snapshot } from '../internal/type';\nimport { helpersQueryKeys, invalidateQueries, updateItemsFromQueryCache } from '../utils/queries';\nimport { createSnapshot } from '../internal/utils/create-snapshot';\nimport { undoEventEmitter } from '../internal/utils/undo-event-emitter';\nimport { IS_TEST_ENV } from '../internal/env';\n\n/** @notExported */\ntype MutateBaseVariables<TPath extends string, TFormData, TType, TExtraData> = (\n  TType extends 'many' ? {\n    ids: (string | number)[];\n    data: TFormData;\n    resource: Resource<TPath>;\n    apiClientParams?: Partial<ApiProps>;\n    extraData?: TExtraData;\n  } : {\n    id: string | number;\n    data: TFormData;\n    resource: Resource<TPath>;\n    apiClientParams?: Partial<ApiProps>;\n    extraData?: TExtraData;\n  }\n)\n\n/** @notExported */\ntype UpdateBaseVariables<TPath extends string, TFormData, TType, TExtraData> = (\n  Omit<MutateBaseVariables<TPath, TFormData, TType, TExtraData>, 'resource'> & {\n    resourceParams: Resource<TPath>['params'];\n    undoMessage?: string;\n  }\n);\n\n/** @notExported */\ntype UpdateBase<TPath extends string, TData, TFormData, TType extends MutationMode, TExtraData> = {\n  resourcePath: Resource<TPath>['path'];\n  mutationOptions?: UseMutateProps<\n    TType extends 'many' ? QueryResponse<TData>[] : QueryResponse<TData>,\n    MutateBaseVariables<TPath, TFormData, TType, TExtraData>\n  >;\n  mode?: MutateMode;\n  extraResources?: Resource<any>[];\n  shouldUpdateCurrentResource?: boolean;\n  isInvalidateCache?: boolean;\n  type: TType;\n}\n\nconst useUpdateBase = <\n  TPath extends string,\n  TData = any,\n  TFormData = OnlyObject,\n  TType extends MutationMode = 'many',\n  TExtraData = any,\n>({\n    resourcePath,\n    mutationOptions,\n    mode = {\n      optimistic: true,\n      undoable: true,\n    },\n    extraResources = [],\n    shouldUpdateCurrentResource = true,\n    isInvalidateCache = true,\n    type = 'many' as TType,\n  }: UpdateBase<TPath, TData, TFormData, TType, TExtraData>) => {\n  const {\n    apiUrl, apiClient, apiEnsureTrailingSlash, toastUndo,\n  } = useRQWrapperContext();\n  const queryClient = useQueryClient();\n\n  const snapshot = useRef<Snapshot>([]);\n  const backToSnapshot = () => {\n    snapshot.current.forEach(([key, value]) => {\n      queryClient.setQueryData(key, value);\n    });\n  };\n\n  const { mutate, ...mutation } = useMutation<\n    TType extends 'many' ? QueryResponse<TData>[] : QueryResponse<TData>,\n    CustomError,\n    MutateBaseVariables<TPath, TFormData, TType, TExtraData>\n  >({\n    ...mutationOptions,\n    mutationKey: [\n      type === 'many' ? 'update-many' : 'update-one',\n      resourcePath,\n      ...(mutationOptions?.mutationKey ? mutationOptions.mutationKey : []),\n    ] as MutateKey<TPath>,\n    mutationFn: async (variables) => {\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, true)}`;\n\n      if (mutationOptions?.mutationFn) {\n        const results = await mutationOptions?.mutationFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const ids = type === 'many'\n        ? (variables as MutateBaseVariables<TPath, TFormData, 'many', TExtraData>).ids\n        : [(variables as MutateBaseVariables<TPath, TFormData, 'one', TExtraData>).id];\n\n      const actions = await Promise.allSettled(ids.map((id) => apiClient<TData>({\n        url: `${url}${id}${apiEnsureTrailingSlash ? '/' : ''}`,\n        method: 'PATCH',\n        data: variables.data,\n        ...variables.apiClientParams,\n      })));\n\n      const result: QueryResponse<TData>[] = [];\n\n      actions.forEach((response) => {\n        if (response.status === 'fulfilled') {\n          result.push(response.value);\n        } else {\n          throw response.reason;\n        }\n      });\n\n      return (type === 'many' ? result : result[0]) as any;\n    },\n    onSuccess: (...rest) => {\n      const variables = rest[1];\n\n      if (isInvalidateCache) {\n        const ids = type === 'many'\n          ? (variables as MutateBaseVariables<TPath, TFormData, 'many', TExtraData>).ids\n          : [(variables as MutateBaseVariables<TPath, TFormData, 'one', TExtraData>).id];\n\n        const queryKeys = [\n          ...helpersQueryKeys.getOneArray(variables.resource, ids),\n          helpersQueryKeys.getList(variables.resource),\n          helpersQueryKeys.getInfiniteList(variables.resource),\n        ];\n\n        extraResources.forEach((extResource) => {\n          queryKeys.push(...helpersQueryKeys.getOneArray(extResource, ids));\n          queryKeys.push(helpersQueryKeys.getList(extResource));\n          queryKeys.push(helpersQueryKeys.getInfiniteList(extResource));\n        });\n\n        invalidateQueries({ queryKeys });\n      }\n\n      if (mutationOptions?.onSuccess) {\n        mutationOptions.onSuccess(...rest);\n      }\n    },\n    onError: (...rest) => {\n      if (mutationOptions?.onError) {\n        mutationOptions.onError(...rest);\n      }\n\n      backToSnapshot();\n    },\n  });\n\n  const update = async ({ resourceParams, undoMessage, ...variables }: UpdateBaseVariables<TPath, TFormData, TType, TExtraData>) => {\n    const resource: Resource<TPath> = {\n      path: resourcePath,\n      params: resourceParams,\n    };\n\n    const ids = type === 'many'\n      ? (variables as any as UpdateBaseVariables<TPath, TFormData, 'many', TExtraData>).ids\n      : [(variables as any as UpdateBaseVariables<TPath, TFormData, 'one', TExtraData>).id];\n\n    if (mode.optimistic) {\n      const queryKeysOne = shouldUpdateCurrentResource ? helpersQueryKeys.getOneArray(resource, ids) : [];\n      const queryKeysList = shouldUpdateCurrentResource ? [helpersQueryKeys.getList(resource)] : [];\n      const queryKeysInfiniteList = shouldUpdateCurrentResource ? [helpersQueryKeys.getInfiniteList(resource)] : [];\n\n      extraResources.forEach((extResource) => {\n        queryKeysOne.push(...helpersQueryKeys.getOneArray(extResource, ids));\n        queryKeysList.push(helpersQueryKeys.getList(extResource));\n        queryKeysInfiniteList.push(helpersQueryKeys.getInfiniteList(extResource));\n      });\n\n      snapshot.current = await createSnapshot([\n        ...queryKeysOne,\n        ...queryKeysList,\n        ...queryKeysInfiniteList,\n      ]);\n\n      updateItemsFromQueryCache({\n        data: variables.data as any,\n        ids,\n        queryKeysOne,\n        queryKeysList,\n        queryKeysInfiniteList,\n      });\n    }\n\n    if (mode.undoable && !IS_TEST_ENV) {\n      const isMany = ids.length > 1;\n\n      undoEventEmitter.once('end', (isUndo) => {\n        if (isUndo) {\n          backToSnapshot();\n        } else {\n          mutate({ ...variables, resource } as any);\n        }\n      });\n\n      toastUndo({\n        message: undoMessage || `Element${isMany ? 's' : ''} updated`,\n        type: isMany ? 'update-many' : 'update-one',\n      });\n    } else {\n      mutate({ ...variables, resource } as any);\n    }\n  };\n\n  return {\n    mutation,\n    update,\n  };\n};\n\n/**\n * A hook that helps you update a single resource.\n *\n * The hook uses `useMutation` from `@tanstack/react-query` under the hood, so it accepts all the same options.\n * It performs an optimistic update by immediately applying the update to the cache before\n * the update request is sent. If the update request fails, the previous state is restored\n * in the cache.\n *\n * If the `undoable` mode is enabled, the hook allows the update to be undone within a certain\n * period of time. If the undo action is not performed, the update will be applied permanently.\n *\n * @example\n * import { useUpdateOne } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * type TFormData = { name: string };\n * const PATH = 'users/{id}/messages';\n *\n * const { update } = useUpdateOne<typeof PATH, TData, TFormData>({\n *   resourcePath: PATH,\n * });\n *\n * update({\n *   id: 123,\n *   data: { name: 'John Doe' },\n *   resourceParams: { id: 1 },\n *   undoMessage: 'Message updated',\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n * @template TFormData - The shape of the data that will be sent to the API during the mutation.\n *\n * @param props The options for the hook.\n * @returns An object with a single properties, `update` and `mutation`.\n *\n * `update` is a function to perform the update operation.\n * Accepts the ID, data, and params of the resource.\n *\n * `mutation` is result `useMutation` without propery `mutate`\n */\nexport const useUpdateOne = <\n  TPath extends string,\n  TData = any,\n  TFormData = OnlyObject,\n  TExtraData = any,\n>(props: Omit<UpdateBase<TPath, TData, TFormData, 'one', TExtraData>, 'type'>) => {\n  return useUpdateBase({ ...props, type: 'one' });\n};\n\n/**\n * A hook that helps you update multiple resources.\n *\n * The hook uses `useMutation` from `@tanstack/react-query` under the hood, so it accepts all the same options.\n * It performs an optimistic update by immediately applying the update to the cache before\n * the update request is sent. If the update request fails, the previous state is restored\n * in the cache.\n *\n * If the `undoable` mode is enabled, the hook allows the update to be undone within a certain\n * period of time. If the undo action is not performed, the updates will be applied permanently.\n *\n * @example\n * import { useUpdateMany } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * type TFormData = { status: 'active' | 'inactive' };\n * const PATH = 'users/{id}/messages';\n *\n * const { update } = useUpdateMany<typeof PATH, TData, TFormData>({\n *   resourcePath: PATH,\n * });\n *\n * update({\n *   ids: [123, 456],\n *   data: { status: 'active' },\n *   resourceParams: { id: 1 },\n *   undoMessage: 'Messages updated',\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n * @template TFormData - The shape of the data that will be sent to the API during the mutation.\n *\n * @param props The options for the hook.\n *\n * `update` is a function to perform the update operation.\n * Accepts the array of IDs, data, and params of the resources.\n *\n * `mutation` is result `useMutation` without propery `mutate`\n */\nexport const useUpdateMany = <\n  TPath extends string,\n  TData = any,\n  TFormData = OnlyObject,\n  TExtraData = any,\n>(props: Omit<UpdateBase<TPath, TData, TFormData, 'many', TExtraData>, 'type'>) => {\n  return useUpdateBase({ ...props, type: 'many' });\n};\n","import { useMutation } from '@tanstack/react-query';\nimport {\n  Resource,\n  UseMutateProps,\n  QueryResponse,\n  OnlyObject,\n  MutateKey,\n  ApiProps,\n} from '../type';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { CustomError } from '../utils/custom-error';\nimport {\n  addItemsToListQueryCache, addItemToQueryCache, helpersQueryKeys, invalidateQueries,\n} from '../utils/queries';\n\n/** @notExported */\ntype MutateVariables<TPath extends string, TFormData, TExtraData> = {\n  data: TFormData;\n  resource: Resource<TPath>;\n  apiClientParams?: Partial<ApiProps>;\n  extraData?: TExtraData;\n}\n\n/** @notExported */\ntype CreateOneVariables<TPath extends string, TFormData, TExtraData> = (\n  Omit<MutateVariables<TPath, TFormData, TExtraData>, 'resource'> & {\n    resourceParams: Resource<TPath>['params'];\n  }\n);\n\n/**\n * A hook that helps you create a new resource.\n *\n * The hook uses `useMutation` from `@tanstack/react-query` under the hood, so it accepts all the same options.\n *\n * The hook returns an object with a single property, `create`, which is a function\n * that takes the data and params of the resource to create, and calls the mutation\n * function with the data and the resource.\n *\n * The hook also sets the query data for the created resource and invalidates the list\n * of resources, so that the list is refetched when the mutation is successful.\n *\n * @example\n * import { useCreate } from '@tanstack/react-query-paginate';\n *\n * type TData = { id: 1, name: 'Test' };\n * type TFormData = { name: string; email: string };\n * const PATH = 'users/{id}/messages';\n *\n * const { create } = useCreate<typeof PATH, TData, TFormData>({\n *   resourcePath: PATH,\n * });\n *\n * create({\n *   data: {\n *     name: 'John Doe',\n *     email: 'john@example.com',\n *   },\n *  resourceParams: {\n *    id: 10,\n *  },\n *   params: {\n *     teamId: 1,\n *   },\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n * @template TFormData - The shape of the data that will be sent to the API during the mutation.\n *\n * @param options The options for the hook.\n * @returns An object with a single properties, `create` and `mutation`.\n *\n * `create` is a function that takes the data and params of the resource to create,\n * and calls the mutation function with the data and the resource.\n *\n * `mutation` is result `useMutation` without propery `mutate`\n */\nexport const useCreate = <\n  TPath extends string,\n  TData = any,\n  TFormData = OnlyObject,\n  TExtraData = any\n>({\n    resourcePath,\n    mutationOptions,\n    extraResources = [],\n    shouldUpdateCurrentResource = true,\n    cacheAddItemTo = 'start',\n    isInvalidateCache = true,\n  } : {\n  resourcePath: Resource<TPath>['path'];\n  mutationOptions?: UseMutateProps<\n    QueryResponse<TData> | QueryResponse<TData>[],\n    MutateVariables<TPath, TFormData, TExtraData>\n  >;\n  extraResources?: Resource<any>[];\n  shouldUpdateCurrentResource?: boolean;\n  cacheAddItemTo?: 'start' | 'end';\n  isInvalidateCache?: boolean;\n}) => {\n  const { apiUrl, apiClient, apiEnsureTrailingSlash } = useRQWrapperContext();\n\n  const { mutate, ...mutation } = useMutation<\n    QueryResponse<TData> | QueryResponse<TData>[],\n    CustomError,\n    MutateVariables<TPath, TFormData, TExtraData>\n  >({\n    ...mutationOptions,\n    mutationKey: [\n      'create',\n      resourcePath,\n      ...(mutationOptions?.mutationKey ? mutationOptions.mutationKey : []),\n    ] as MutateKey<TPath>,\n    mutationFn: async (variables) => {\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, apiEnsureTrailingSlash)}`;\n\n      if (mutationOptions?.mutationFn) {\n        const results = await mutationOptions?.mutationFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const result = await apiClient<TData>({\n        url,\n        method: 'POST',\n        data: variables.data,\n        ...variables.apiClientParams,\n      });\n\n      return result;\n    },\n    onSuccess: (...rest) => {\n      const data = rest[0];\n\n      if (data) {\n        const variables = rest[1];\n\n        const queryKeysList = shouldUpdateCurrentResource ? [helpersQueryKeys.getList(variables.resource)] : [];\n        const queryKeysInfiniteList = shouldUpdateCurrentResource ? [helpersQueryKeys.getInfiniteList(variables.resource)] : [];\n\n        extraResources.forEach((extResource) => {\n          queryKeysList.push(helpersQueryKeys.getList(extResource));\n          queryKeysInfiniteList.push(helpersQueryKeys.getInfiniteList(extResource));\n        });\n\n        const responses = Array.isArray(data) ? data : [data];\n\n        responses.forEach((response) => {\n          if (response) {\n            const { id } = response!.data as any;\n\n            const queryKeysOne = shouldUpdateCurrentResource ? [helpersQueryKeys.getOne(variables.resource, id)] : [];\n\n            extraResources.forEach((extResource) => {\n              queryKeysOne.push(helpersQueryKeys.getOne(extResource, id));\n            });\n\n            addItemToQueryCache({\n              data: response,\n              queryKeysOne: queryKeysOne.map((item) => ([...item, {}])),\n            });\n          }\n        });\n\n        addItemsToListQueryCache({\n          data: responses.map((response) => (response?.data || {})),\n          cacheAddItemTo,\n          queryKeysInfiniteList,\n          queryKeysList,\n        });\n\n        if (isInvalidateCache) {\n          invalidateQueries({\n            queryKeys: [...queryKeysList, ...queryKeysInfiniteList],\n          });\n        }\n      }\n\n      if (mutationOptions?.onSuccess) {\n        mutationOptions.onSuccess(...rest);\n      }\n    },\n  });\n\n  const create = ({ resourceParams, ...variables }: CreateOneVariables<TPath, TFormData, TExtraData>) => {\n    const resource: Resource<TPath> = {\n      path: resourcePath,\n      params: resourceParams,\n    };\n\n    mutate({ ...variables, resource });\n  };\n\n  return {\n    mutation,\n    create,\n  };\n};\n","import { useQuery } from '@tanstack/react-query';\nimport {\n  Resource,\n  UseQueryProps,\n  QueryResponse,\n  QueryDataKey,\n  ApiProps,\n} from '../type';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { CustomError } from '../utils/custom-error';\n\n/**\n * A hook that helps you fetch a resource.\n *\n * The hook uses `useQuery` from `@tanstack/react-query` to fetch data and cache it.\n * It accepts various query options and performs an API request to fetch a list of resources\n * based on the provided `resource` and `params`. The hook supports additional query parameters\n * and custom API client parameters.\n *\n * If a custom `queryFn` is provided, it will be used to perform the query; otherwise,\n * the default API client method will be used. The `queryKey` is constructed based on\n * the resource path and additional parameters to ensure proper caching and refetching.\n *\n * @example\n * import { useDataQuery } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * const PATH = 'users/{id}/messages';\n *\n * const queryList = useDataQuery<typeof PATH, TData>({\n *   resource: { path: PATH, params: { id: 1 } },\n *   queryOptions: {\n *     onSuccess: (data) => {\n *       console.log('Data fetched successfully:', data);\n *     },\n *   },\n *   params: { sortBy: 'date', order: 'asc' },\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n *\n * @param params The parameters for the hook.\n * @param params.queryOptions - Additional options to configure the `useQuery`\n * @param params.resource - The resource path and any static parameters for the API request.\n * @param params.params - Dynamic query parameters for the API request.\n * @param params.apiClientParams - Additional options to pass to the API client.\n *\n * @returns The result of the `useQuery` hook.\n */\nexport const useDataQuery = <TPath extends string, TData = any>({\n  queryOptions,\n  resource,\n  params = {},\n  apiClientParams,\n}: {\n  queryOptions?: UseQueryProps<\n    QueryResponse<TData>,\n    QueryDataKey<TPath>,\n    {\n      resource: Resource<TPath>;\n      params: QueryDataKey<TPath>['3'];\n      queryKey: QueryDataKey<TPath>;\n    }\n  >;\n  resource: Resource<TPath>;\n  params?: QueryDataKey<TPath>['3'];\n  apiClientParams?: Partial<ApiProps>;\n}) => {\n  const { apiUrl, apiClient, apiEnsureTrailingSlash } = useRQWrapperContext();\n\n  const query = useQuery<\n    QueryResponse<TData>,\n    CustomError,\n    QueryResponse<TData>,\n    QueryDataKey<TPath>\n  >({\n    ...queryOptions,\n    queryKey: [\n      'query-data',\n      resource.path,\n      resource.params,\n      params,\n      ...(queryOptions?.queryKey ? queryOptions.queryKey : []),\n    ] as QueryDataKey<TPath>,\n    queryFn: async ({ queryKey }) => {\n      const variables = { resource, params, queryKey };\n\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, apiEnsureTrailingSlash)}`;\n\n      if (queryOptions?.queryFn) {\n        const results = await queryOptions?.queryFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const result = await apiClient({\n        url, method: 'GET', params, ...apiClientParams,\n      });\n\n      return result;\n    },\n  });\n\n  return query;\n};\n","import { useMutation } from '@tanstack/react-query';\nimport {\n  Resource,\n  UseMutateProps,\n  QueryResponse,\n  MutateDataKey,\n  ApiProps,\n} from '../type';\nimport { useRQWrapperContext } from '../components/RQWrapper';\nimport { getUrlFromResource } from '../utils/get-url-from-resource';\nimport { CustomError } from '../utils/custom-error';\n\n/** @notExported */\ntype Variables<TPath extends string, TFormData, TExtraData> = {\n  data: TFormData;\n  resource: Resource<TPath>;\n  apiClientParams: Partial<ApiProps> & {\n    method: ApiProps['method']\n  };\n  extraData?: TExtraData;\n}\n\n/** @notExported */\ntype MutateVariables<TPath extends string, TFormData, TExtraData> = (\n  Omit<Variables<TPath, TFormData, TExtraData>, 'resource'> & {\n    resourceParams: Resource<TPath>['params'];\n  }\n);\n\n/**\n * A hook that helps you mutate a resource.\n *\n * The hook uses `useMutation` from `@tanstack/react-query` under the hood, so it accepts all the same options.\n *\n * @example\n * import { useDataMutate } from 'react-query-manager';\n *\n * type TData = { id: 1, name: 'Test' };\n * type TFormData = { name: string; email: string };\n * const PATH = 'users/{id}/messages';\n *\n * const { mutate } = useDataMutate<typeof PATH, TData, TFormData>({\n *   resourcePath: PATH,\n * });\n *\n * mutate({\n *   data: {\n *     name: 'John Doe',\n *     email: 'john@example.com',\n *   },\n *   resourceParams: {\n *     id: 10,\n *   },\n *   apiClientParams: { method: 'POST' },\n * });\n *\n * @template TPath - The API path as a string.\n * @template TData - The expected shape of the data returned by the API.\n * @template TFormData - The shape of the data that will be sent to the API during the mutation.\n *\n * @param props The options for the hook.\n *\n * @returns An object with `mutate` and `mutation`.\n *\n * `mutate` is a function to perform the update operation.\n * Accepts the data and params of the resource.\n *\n * `mutation` is result `useMutation` without propery `mutate`\n */\nexport const useDataMutate = <TPath extends string, TData = any, TFormData = any, TExtraData = any>({\n  resourcePath,\n  mutationOptions,\n}: {\n  resourcePath: Resource<TPath>['path'];\n  mutationOptions?: UseMutateProps<\n    QueryResponse<TData>,\n    Variables<TPath, TFormData, TExtraData>\n  >;\n}) => {\n  const {\n    apiUrl, apiClient, apiEnsureTrailingSlash,\n  } = useRQWrapperContext();\n\n  const { mutate: onMutate, ...mutation } = useMutation<\n    QueryResponse<TData>,\n    CustomError,\n    Variables<TPath, TFormData, TExtraData>\n  >({\n    ...mutationOptions,\n    mutationKey: [\n      'mutate-data',\n      resourcePath,\n      ...(mutationOptions?.mutationKey ? mutationOptions.mutationKey : []),\n    ] as MutateDataKey<TPath>,\n    mutationFn: async (variables) => {\n      const url = `${apiUrl}/${getUrlFromResource(variables.resource, apiEnsureTrailingSlash)}`;\n\n      if (mutationOptions?.mutationFn) {\n        const results = await mutationOptions?.mutationFn({\n          apiClient, apiUrl, variables, url,\n        });\n        return results;\n      }\n\n      const result = await apiClient<TData>({\n        url,\n        data: variables.data,\n        ...variables.apiClientParams,\n      });\n\n      return result;\n    },\n  });\n\n  const mutate = async ({ resourceParams, ...variables }: MutateVariables<TPath, TFormData, TExtraData>) => {\n    const resource: Resource<TPath> = {\n      path: resourcePath,\n      params: resourceParams,\n    };\n\n    onMutate({ ...variables, resource });\n  };\n\n  return {\n    mutation,\n    mutate,\n  };\n};\n"],"mappings":"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","names":["CustomError","_CustomError","message","status","data","filterEmptyParams","params","optionParams","key","value","encode","fetcher","onSuccess","onError","context","args","isFormData","apiUrl","URL","queryParams","str","p","startUrl","endUrl","body","fetchOptions","response","responseData","contentLength","contentType","headers","result","error","CustomError","useQuery","removeFirstAndLastSlash","path","getUrlFromResource","resource","ensureTrailingSlash","url","removeFirstAndLastSlash","_","key","QueryClient","QueryClientProvider","ReactQueryDevtools","React","createContext","useCallback","useContext","useMemo","React","useCallback","resolveValue","useToaster","prefersReducedMotion","shouldReduceMotion","mediaQuery","ToastWrapper","id","className","style","onHeightUpdate","children","ref","el","updateHeight","height","getPositionStyle","position","offset","top","verticalStyle","horizontalStyle","DEFAULT_OFFSET","Toaster","reverseOrder","toastOptions","gutter","containerStyle","containerClassName","toasts","handlers","t","toastPosition","toast","positionStyle","Component","toastApi","ToastBarToast","resolveValue","remove","restOfToastApi","toast","args","ToastBar","resolveToastValue","EventEmitter","eventEmitter","undoEventEmitter","type","callback","isUndo","IS_TEST_ENV","queryClientManager","getQueryClient","Context","createContext","fetcher","useRQWrapperContext","useContext","RQWrapper","children","config","apiUrl","apiClient","apiEnsureTrailingSlash","apiAuthorization","apiHeaders","apiOnSuccess","apiOnError","isDevTools","devToolsOptions","toastProps","queryClient","useMemo","client","QueryClient","queryClientManager","fetch","useCallback","args","globalAuthorization","globalHeaders","onSuccess","successArgs","onError","errorArgs","toastUndo","data","isSuccess","toast","onUndo","undoEventEmitter","IS_TEST_ENV","t","CustomContent","React","contextValue","removeFirstAndLastSlash","QueryClientProvider","Toaster","ReactQueryDevtools","useGetList","queryOptions","resource","params","apiClientParams","apiUrl","apiClient","apiEnsureTrailingSlash","useRQWrapperContext","useQuery","queryKey","variables","url","getUrlFromResource","useInfiniteQuery","useGetInfiniteList","queryOptions","resource","params","apiClientParams","pagination","apiUrl","apiClient","apiEnsureTrailingSlash","useRQWrapperContext","useInfiniteQuery","args","lastPage","lastPageParam","firstPageParam","queryKey","pageParam","variables","url","getUrlFromResource","useQuery","useGetOne","resource","id","queryOptions","params","apiClientParams","apiUrl","apiClient","apiEnsureTrailingSlash","useRQWrapperContext","useQuery","queryKey","variables","url","getUrlFromResource","useMutation","useQueryClient","useRef","addItemToQueryCache","data","queryKeysOne","queryClient","getQueryClient","queryKeyOne","addItemsToListQueryCache","data","queryKeysList","queryKeysInfiniteList","cacheAddItemTo","queryClient","getQueryClient","updateListData","page","queryKey","old","removeQueries","queryKeys","queryClient","getQueryClient","queryKey","deleteItemsFromQueryCache","ids","queryKeysOne","queryKeysList","queryKeysInfiniteList","queryClient","getQueryClient","updateListData","page","item","id","removeQueries","queryKey","old","helpersQueryKeys","itemResource","id","ids","isEqual","data1","data2","keys1","keys2","key","value1","value2","i","invalidateMatchingQueries","queryKeys","getQueryClient","query","keys","keyGroup","matchKey","key","isEqual","removeMatchingQueries","queryKeys","getQueryClient","query","keys","keyGroup","matchKey","key","isEqual","invalidateQueries","queryKeys","queryClient","getQueryClient","queryKey","isCanConvertToNumber","value","isCanNumber","value1","value2","mergeObjects","target","source","result","key","targetValue","sourceValue","isSameType","canConvertToNumber","updateItemsFromQueryCache","data","ids","queryKeysOne","queryKeysList","queryKeysInfiniteList","queryClient","getQueryClient","updateListData","page","item","id","mergeObjects","queryKeyOne","old","queryKey","createSnapshot","keys","queryClient","getQueryClient","snapshot","prev","queryKey","useDeleteBase","resourcePath","mutationOptions","mode","extraResources","shouldUpdateCurrentResource","isInvalidateCache","type","apiUrl","apiClient","apiEnsureTrailingSlash","toastUndo","useRQWrapperContext","queryClient","useQueryClient","snapshot","useRef","backToSnapshot","key","value","mutate","mutation","useMutation","variables","url","getUrlFromResource","ids","actions","id","result","response","rest","queryKeys","helpersQueryKeys","extResource","invalidateQueries","resourceParams","undoMessage","resource","queryKeysOne","queryKeysList","queryKeysInfiniteList","createSnapshot","deleteItemsFromQueryCache","IS_TEST_ENV","isMany","undoEventEmitter","isUndo","useDeleteOne","props","useDeleteMany","useMutation","useQueryClient","useRef","useUpdateBase","resourcePath","mutationOptions","mode","extraResources","shouldUpdateCurrentResource","isInvalidateCache","type","apiUrl","apiClient","apiEnsureTrailingSlash","toastUndo","useRQWrapperContext","queryClient","useQueryClient","snapshot","useRef","backToSnapshot","key","value","mutate","mutation","useMutation","variables","url","getUrlFromResource","ids","actions","id","result","response","rest","queryKeys","helpersQueryKeys","extResource","invalidateQueries","resourceParams","undoMessage","resource","queryKeysOne","queryKeysList","queryKeysInfiniteList","createSnapshot","updateItemsFromQueryCache","IS_TEST_ENV","isMany","undoEventEmitter","isUndo","useUpdateOne","props","useUpdateMany","useMutation","useCreate","resourcePath","mutationOptions","extraResources","shouldUpdateCurrentResource","cacheAddItemTo","isInvalidateCache","apiUrl","apiClient","apiEnsureTrailingSlash","useRQWrapperContext","mutate","mutation","useMutation","variables","url","getUrlFromResource","rest","data","queryKeysList","helpersQueryKeys","queryKeysInfiniteList","extResource","responses","response","id","queryKeysOne","addItemToQueryCache","item","addItemsToListQueryCache","invalidateQueries","resourceParams","useQuery","useDataQuery","queryOptions","resource","params","apiClientParams","apiUrl","apiClient","apiEnsureTrailingSlash","useRQWrapperContext","useQuery","queryKey","variables","url","getUrlFromResource","useMutation","useDataMutate","resourcePath","mutationOptions","apiUrl","apiClient","apiEnsureTrailingSlash","useRQWrapperContext","onMutate","mutation","useMutation","variables","url","getUrlFromResource","resourceParams"]}